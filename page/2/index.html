<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png?v=7.4.1">
  <link rel="mask-icon" href="/images/avatar.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Mr.RS">
<meta property="og:url" content="https://mrrs878.github.io/page/2/index.html">
<meta property="og:site_name" content="Mr.RS">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.RS">
  <link rel="canonical" href="https://mrrs878.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Mr.RS</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.RS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Read The Fucking Source Code!</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      
    
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/04/02/浏览器相关-存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/04/02/浏览器相关-存储/" class="post-title-link" itemprop="url">浏览器相关-存储</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-02 22:49:39" itemprop="dateCreated datePublished" datetime="2020-04-02T22:49:39+08:00">2020-04-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 23:18:46" itemprop="dateModified" datetime="2020-04-08T23:18:46+08:00">2020-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浏览器/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于存储的问题都会涉及到三个问题:</p>
<ol>
<li>存储场所</li>
<li>存储空间</li>
<li>存储时间</li>
</ol>
<p>(在哪儿存储，多少数据，到什么时候)这些特性决定了不同方案的用途</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li><p>WHAT</p>
<p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699f22b7029ca14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cookie的原理"></p>
</li>
<li><p>WHY</p>
<p>cookie的本职工作并非进行本地存储，而是<strong>维持状态</strong>。因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了<strong>交互式Web程序</strong>的实现，于是就诞生了cookie。他就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取cookie中包含信息，借此维护用户跟服务器会话的状态</p>
<p>cookie的缺陷：</p>
<ul>
<li>cookie不够大，各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</li>
<li>过多的 Cookie 会带来巨大的性能浪费，每次请求都会携带cookie</li>
<li>安全性较差，由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS</li>
</ul>
</li>
<li><p>HOW</p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<p>cookie的生成方式主要有两种：</p>
<ol>
<li><p><code>http response header</code>中的<code>set-cookie</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2019</span> <span class="number">22</span>:<span class="number">28</span>:<span class="number">00</span> GMT;<span class="comment">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>js中通过<code>document.cookie</code>可以读写cookie，以键值对的形式展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"userName=mrrs878"</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"age=23"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>常用后缀及其含义：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>如果用于保存用户登录态，应该将值加密，不能使用明文的用户标识</td>
</tr>
<tr>
<td>http-only</td>
<td>不能通过JS访问cookie，减少XSS攻击</td>
</tr>
<tr>
<td>secure</td>
<td>只能在协议为HTTPS的请求中携带</td>
</tr>
<tr>
<td>same-site</td>
<td>规定浏览器不能再跨域请求中携带cookie，减少CSRF攻击</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。<strong>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage</strong>。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>特点：</p>
<ul>
<li>持久化存储</li>
<li>数据大小限制提升到5M</li>
<li>仅在客户端使用，不与服务器通信</li>
</ul>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line">localStorage.setItem(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">localStorage.getItem(<span class="string">"key"</span>)；</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>存储一些稳定的资源，如图片转为base64存储在本地加快访问</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>特点：</p>
<ul>
<li>会话级别的存储（包括父页面生成的新标签页）</li>
<li>数据大小限制提升到5M</li>
<li>仅在客户端使用，不与服务器通信</li>
</ul>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>)</span><br><span class="line">sessionStorage.getItem(<span class="string">'key'</span>, <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>对表单信息进行维护，比如刷新时，表单信息不丢失</p>
<h2 id="cookie、localstorage、sessionstorage的区别"><a href="#cookie、localstorage、sessionstorage的区别" class="headerlink" title="cookie、localstorage、sessionstorage的区别"></a>cookie、localstorage、sessionstorage的区别</h2><table>
<thead>
<tr>
<th></th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>由谁初始化</td>
<td>客户端或服务器，服务器可以使用Set-Cookie请求头</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>存储位置</td>
<td>客户端</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>过期时间</td>
<td>手动设置</td>
<td>无</td>
<td>当前会话</td>
</tr>
<tr>
<td>在当前会话中保持不变</td>
<td>取决过期时间</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否随着请求发送给服务器</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>容量</td>
<td>4Kb(单个name)</td>
<td>5Mb(单个域名)</td>
<td>5Mb(单个域名)</td>
</tr>
<tr>
<td>访问权限</td>
<td>任意窗口</td>
<td>任意窗口</td>
<td>当前窗口</td>
</tr>
</tbody></table>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是一种低级API，<strong>用于客户端存储大量结构化数据(包括文件和blobs)</strong>。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。</p>
<p>特点：</p>
<ul>
<li>键值对储存</li>
<li>异步</li>
<li>事务</li>
<li>同源限制</li>
<li>支持二进制存储</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/04/01/HTML相关-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/04/01/HTML相关-0/" class="post-title-link" itemprop="url">HTML相关问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-01 23:00:40 / 修改时间：23:01:55" itemprop="dateCreated datePublished" datetime="2020-04-01T23:00:40+08:00">2020-04-01</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cookie、sessionStorage、localStorage的区别"><a href="#cookie、sessionStorage、localStorage的区别" class="headerlink" title="cookie、sessionStorage、localStorage的区别"></a>cookie、sessionStorage、localStorage的区别</h2><table>
<thead>
<tr>
<th></th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>由谁初始化</td>
<td>客户端或服务器，服务器可以使用Set-Cookie请求头</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>存储位置</td>
<td>客户端</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>过期时间</td>
<td>手动设置</td>
<td>无</td>
<td>当前会话</td>
</tr>
<tr>
<td>在当前会话中保持不变</td>
<td>取决过期时间</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否随着请求发送给服务器</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>容量（每个域名）</td>
<td>4Kb</td>
<td>5MB</td>
<td>5MB</td>
</tr>
<tr>
<td>访问权限</td>
<td>任意窗口</td>
<td>任意窗口</td>
<td>当前窗口</td>
</tr>
</tbody></table>
<h2 id="lt-script-gt-、-lt-script-async-gt-、-lt-script-defer-gt-区别"><a href="#lt-script-gt-、-lt-script-async-gt-、-lt-script-defer-gt-区别" class="headerlink" title="&lt;script&gt; 、&lt;script async&gt;、 &lt;script defer&gt; 区别"></a><code>&lt;script&gt;</code> 、<code>&lt;script async&gt;</code>、 <code>&lt;script defer&gt;</code> 区别</h2><p>当遇到这些标签时，会发生以下几种情况：</p>
<ul>
<li><code>script</code>，HTML解析中断，脚本被提取并立即执行，执行结束后，<code>HTML</code>解析继续</li>
<li><code>script async</code>，脚本的提取、执行的过程与<code>HTML</code>解析过程并行，脚本执行完毕可能在<code>HTML</code>解析完毕前。当脚本与页面上其他脚本独立时，可以使用<code>async</code>来加快页面渲染（比如用作页面统计分析）</li>
<li><code>script defer</code>，脚本的提取过程与<code>HTML</code>解析过程并行，脚本的执行将在<code>HTML</code>解析完毕后进行。如果有多个含<code>defer</code>的脚本，脚本的执行顺序按照在<code>document</code>中出现的位置，从上到下顺序执行。</li>
</ul>
<p>👀：没有<code>src</code>的脚本，<code>async</code>和<code>defer</code>属性会被忽略</p>
<h2 id="lt-link-gt-与-lt-script-gt-的放置位置"><a href="#lt-link-gt-与-lt-script-gt-的放置位置" class="headerlink" title="&lt;link&gt;与&lt;script&gt;的放置位置"></a><code>&lt;link&gt;</code>与<code>&lt;script&gt;</code>的放置位置</h2><ul>
<li><p>把<code>&lt;link&gt;</code>放在<code>&lt;head&gt;</code>中</p>
<p>把<code>link</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。</p>
</li>
<li><p>把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>底部</p>
<p>脚本在下载和执行期间会阻止 HTML 解析。把``标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。</p>
<p>在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，<code>&lt;</code>script<code>&gt;</code>使用<code>defer</code>属性，放在<code>&lt;head&gt;</code>中。</p>
</li>
</ul>
<h2 id="lt-img-gt-的title和alt属性"><a href="#lt-img-gt-的title和alt属性" class="headerlink" title="&lt;img&gt;的title和alt属性"></a><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>属性</h2><ul>
<li><p><code>alt</code></p>
<p><code>alt</code>属性包含一条对图像的文本描述，这不是强制性的，但对可访问性而言，它<strong>难以置信地有用</strong>——屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示<code>alt</code> 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。</p>
</li>
<li><p><code>title</code></p>
<p><code>title</code> 属性不是 <code>alt</code> 属性可接受的替代品。并且，避免将 <code>alt</code> 属性的值直接复制到同一幅图片的<code>title</code> 属性上。这样可能会让一些屏幕阅读器把同一段描述读两遍，造成一定程度上的困扰。</p>
<p><code>title</code> 属性也不该被用作一幅图片在 <code>alt</code> 之外的补充说明信息。如果一幅图片需要小标题，使用 <code>figure</code> 或 <code>figcaption</code> 元素。</p>
<p><code>title</code>元素的值一般作为提示条(<code>tooltip</code>)呈现给用户，在光标于图片上停下后显示出来。尽管这<em>确实</em>能给用户提供更多的信息，您不该假定用户真的能看到：用户可能只有键盘或触摸屏。如果要把特别重要的信息提供给用户，选择上面提供的一种方法将其内联显示，而不是使用 <code>title</code></p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/24/CSS相关-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/24/CSS相关-0/" class="post-title-link" itemprop="url">CSS-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-24 23:29:35 / 修改时间：23:30:19" itemprop="dateCreated datePublished" datetime="2020-03-24T23:29:35+08:00">2020-03-24</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index">
                    <span itemprop="name">CSS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作为一个矩形盒子，这个盒子包含元素的内容、内边距、边框、外边距。</p>
<p>盒模型分为两种：</p>
<ul>
<li><p>标准盒模型（box-sizing = content-box）</p>
<p>width = content-width</p>
<p>height = content-height</p>
</li>
<li><p>IE盒模型（box-sizing = border-box）</p>
<p>width = content-width + padding + border</p>
<p>height = content-height + padding + border</p>
</li>
</ul>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>层叠上下文是<strong>包含一组图层的元素</strong>。 在一组层叠上下文中，其子元素的<strong>z-index值是相对于该父元素</strong>而不是 <code>document root</code> 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的<code>z-index</code>值，元素 C 也永远不会在元素 B 之上.</p>
<p>CSS 中的<code>z-index</code>属性控制重叠元素的垂直叠加顺序。<code>z-index</code>只能影响<code>position</code>值不是<code>static</code>的元素。</p>
<p>产生层叠上下文：</p>
<ol>
<li><p>HTML中的根元素<code>&lt;html&gt;&lt;/html&gt;</code>本身就具有层叠上下文，称为<strong>根层叠上下文</strong>。</p>
</li>
<li><p>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</p>
</li>
<li><p>CSS3中的新属性也可以产生层叠上下文。</p>
</li>
<li><ul>
<li>父元素的display属性值为<code>flex|inline-flex</code>，子元素<code>z-index</code>属性值不为<code>auto</code>的时候，子元素为层叠上下文元素；</li>
<li>元素的<code>opacity</code>属性值不是1；</li>
<li>元素的<code>transform</code>属性值不是<code>none</code>；</li>
<li>元素<code>mix-blend-mode</code>属性值不是normal；</li>
<li>元素的<code>filter</code>属性值不是<code>none</code>；</li>
</ul>
</li>
</ol>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/z-index.png" alt="z-index"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/12/webpack学习-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/12/webpack学习-0/" class="post-title-link" itemprop="url">webpack学习-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-12 23:51:35" itemprop="dateCreated datePublished" datetime="2020-03-12T23:51:35+08:00">2020-03-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-13 23:20:33" itemprop="dateModified" datetime="2020-04-13T23:20:33+08:00">2020-04-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><code>webpack</code>是一个现代的<code>JavaScript</code>应用程序打包工具。当<code>webpack</code>处理应用程序时，会递归构建一个<strong>依赖关系图</strong>，其中包含应用程序需要的每个模块，然后将这个模块打包成一个或多个bundle</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack-0.png" alt="概念图"></p>
<h2 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h2><ul>
<li><p><code>entry</code>（入口）</p>
<p>入口指示<code>webpack</code>应该使用哪个模块来作为构建其内部<strong>依赖图</strong>的开始。进入入口起点后，<code>webpack</code>会找出有哪些模块是库入口起点（直接和间接）依赖的</p>
<p>每个依赖项随即被处理，最后输出到称之为<code>bundles</code>的文件中。</p>
<p>可以通过在<code>webpack</code>配置中配置entry属性来指定一个或多个入口起点。默认为<code>./src</code></p>
</li>
<li><p><code>output</code>（出口）</p>
<p><code>output</code>告诉<code>webpack</code>在哪输出它所创建的<code>bundles</code>，以及如何命名这些文件，默认值为<code>./dist</code>。基本上，整个应用程序结构都会被编译到指定的输出路径的文件夹中。可以通过配置文件中的<code>output</code>字段来指定输出的文件夹</p>
</li>
<li><p><code>loader</code></p>
<p><code>loader</code>让<code>webpack</code>能够去处理那些非<code>JavaScript</code>文件（<code>webpack</code>自身只理解<code>JavaScript</code>）。<code>loader</code>能够将所有类型的文件转换为<code>webpack</code>能够处理的有效模块，然后就可以利用<code>webpack</code>的打包能力对它们进行处理。</p>
<p>同一个<code>rule</code>下的多个<code>loader</code>时将从右往左执行</p>
</li>
<li><p><code>plugin</code></p>
<p><code>loader</code>被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括从打包优化和压缩一直到重新定义环境中的变量，插件接口功能极其强大，可以用来处理各种各样的任务。</p>
<p>想要使用一个插件，只需要<code>require</code>它，然后把它添加到<code>plugins</code>配置项中。多数插件可以通过选项自定义。</p>
</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>webpack</code>的相关配置主要由根目录下的<code>webpack.config.js</code>来完成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    entry: [<span class="string">''</span>]</span><br><span class="line">    output: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    	rules: [&#123;&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">    plugins: [&#123;&#125;],</span><br><span class="line">    devServer: &#123;&#125;,</span><br><span class="line">    devtool: <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理JavaScript-babel-loader"><a href="#处理JavaScript-babel-loader" class="headerlink" title="处理JavaScript:babel-loader"></a>处理JavaScript:babel-loader</h2><p><code>webpack</code>本身可以识别<code>JavaScript</code>，但为了兼容老的浏览器，需要将<code>ES6</code>转换为向后兼容版本的<code>JavaScript</code>代码，<a href="https://babel.docschina.org/" target="_blank" rel="noopener">Babel</a>就是这么一种工具链。</p>
<p>当<code>webpack</code>打包源代码时，可能会很难追踪到错误和警告在源代码中的起始位置。为了<strong>更容易追踪错误和警告</strong>，<code>JavaScript</code>提供了<a href="http://blog.teamtreehouse.com/introduction-source-maps" target="_blank" rel="noopener">source map</a>功能，将编译后的代码映射回原始代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">            use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 开启source-map</span></span><br><span class="line">    devtool: <span class="string">'cheap-module-eval-source-map'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">api</span>) </span>&#123;</span><br><span class="line">    api.cache(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> presets = [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">    <span class="keyword">const</span> plugins = [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                corejs: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        presets,</span><br><span class="line">        plugins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理HTML"><a href="#处理HTML" class="headerlink" title="处理HTML"></a>处理HTML</h2><p>有时为了清除缓存，打包文件时会带有hash，那么每次生成的文件名会有所不同。如果在<code>html</code>中引用了这些文件，则需要更改引入的文件名，手工改动不可取。我们可以使用<code>html-webpack-plugin</code>来帮助处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">// template指定生成html的模板文件</span></span><br><span class="line">            template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">            <span class="comment">// 默认生成在./dist/index.html</span></span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">false</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理-ss"><a href="#处理-ss" class="headerlink" title="处理*ss"></a>处理*ss</h2><ul>
<li><code>style-loader</code>，动态创建<code>style</code>标签，将<code>css</code>插入到<code>head</code>中</li>
<li><code>css-loader</code>，负责处理<code>@import</code>等语句</li>
<li><code>postcss-loader</code>和<code>autoprefixer</code>，自动生成浏览器兼容性前缀</li>
<li><code>less-loader</code>，负责编译<code>.less</code>文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            plugins: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> [</span><br><span class="line">                                    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                                        <span class="string">'overrideBrowserslist'</span>: [</span><br><span class="line">                                            <span class="string">"&gt;0.25%"</span>,</span><br><span class="line">                                            <span class="string">'not dead'</span></span><br><span class="line">                                        ]</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">'less-loader'</span></span><br><span class="line">                ],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理本地资源文件"><a href="#处理本地资源文件" class="headerlink" title="处理本地资源文件"></a>处理本地资源文件</h2><p>可以使用url-loader或file-loader来处理本地的资源文件。url-loader和file-loader功能类似，但是url-loader可以指定文件在小于某一特定值下返回DataURL，可以减少http请求，推荐使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|gif|jpeg|svg|ttf)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: <span class="number">10240</span>,</span><br><span class="line">                            esModule: <span class="literal">false</span>,</span><br><span class="line">                            name: <span class="string">'assets/[name]_[hash:6].[ext]'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，对于html中的图片，url-loader则无能为力，此时需要<code>html-withimg-loader</code>来协助</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.html/</span>,</span><br><span class="line">                use: [<span class="string">'html-withimg-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/10/vuex剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/10/vuex剖析/" class="post-title-link" itemprop="url">vuex剖析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-10 20:50:56 / 修改时间：23:12:33" itemprop="dateCreated datePublished" datetime="2020-03-10T20:50:56+08:00">2020-03-10</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>vuex是专门为Vue.js设计的<strong>状态管理工具</strong>，它采用<strong>集中式存储</strong>管理应用的所有状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h2 id="vuex的构成"><a href="#vuex的构成" class="headerlink" title="vuex的构成"></a>vuex的构成</h2><ul>
<li><p>引入<code>State</code>、<code>Getter</code>对状态进行定义</p>
</li>
<li><p>使用<code>Mutation</code>、<code>Action</code>对状态进行修改</p>
</li>
<li><p>使用<code>Module</code>对状态进行模块化分割</p>
</li>
<li><p>引入插件对状态进行快照、记录、跟踪等</p>
</li>
<li><p>提供<code>mapState</code>、<code>mapGetters</code>、<code>mapActions</code>、<code>mapMutations</code>辅助函数方便开发者处理store</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-0.png" alt="vuex组成"></p>
</li>
</ul>
<h2 id="vuex原理"><a href="#vuex原理" class="headerlink" title="vuex原理"></a>vuex原理</h2><h3 id="vuex的store是如何注入到组件中的"><a href="#vuex的store是如何注入到组件中的" class="headerlink" title="vuex的store是如何注入到组件中的"></a>vuex的store是如何注入到组件中的</h3><ul>
<li><p>通过vue的<a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener">mixin</a>机制，在<code>install</code>函数中借助于vue的<code>beforeCreate</code>生命周期函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>beforeCreate</code>中调用vuexInit将store挂载到当前实例上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="comment">// store injection</span></span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">        <span class="comment">// 根组件通过options.store挂载</span></span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">typeof</span> options.store === <span class="string">'function'</span></span><br><span class="line">            ? options.store()</span><br><span class="line">        	: options.store</span><br><span class="line">        <span class="comment">// 其余组件通过父组件上的store挂载</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = options.parent.$store</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-1.jpg" alt="store注入"></p>
</li>
</ul>
<h3 id="vuex的state和getter是如何映射到各个组件实例中自动更新的"><a href="#vuex的state和getter是如何映射到各个组件实例中自动更新的" class="headerlink" title="vuex的state和getter是如何映射到各个组件实例中自动更新的"></a>vuex的state和getter是如何映射到各个组件实例中自动更新的</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    construcor () &#123;</span><br><span class="line">        resetStoreVM()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> state () &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   	store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       	data: &#123;</span><br><span class="line">       		$$state: state</span><br><span class="line">       	&#125;,</span><br><span class="line">      	computed</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码得知，当使用<code>this.$store.state.xxx</code>时会被代理到<code>store._vm._data.$$state</code>上，而<code>store._vm</code>是一个Vue实例，由于示例中的data是响应式的，所以$$state也是响应式的，那么当更新state时，所有相关组件中的state也会自动更新</p>
<h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    	<span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    	<span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">    	<span class="comment">// using partial to return function with only arguments preserved in closure environment.</span></span><br><span class="line">        computed[key] = partial(fn, store)</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">            <span class="keyword">get</span>: () =&gt; store._vm[key],</span><br><span class="line">            enumerable: true // for local getters</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码得知，当使用<code>this.$store.getter.xxx</code>时会被代理到<code>store._vm.xxx</code>，其中添加<code>computed</code>属性</p>
<p>从上面可以看出，Vuex中的<code>state</code>是借助于一个Vue.js实例，将state存入示例中的<code>data</code>中；Vuex中的<code>getter</code>则是借助于实例的计算属性<code>computed</code>实现数据监听</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-3.png" alt="state、getter响应式"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/09/vue-router剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/09/vue-router剖析/" class="post-title-link" itemprop="url">vue-router剖析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-09 22:05:40 / 修改时间：23:30:51" itemprop="dateCreated datePublished" datetime="2020-03-09T22:05:40+08:00">2020-03-09</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由最早由后端提出，用于根据不同的请求返回不同的页面。大致流程如下：</p>
<ol>
<li>浏览器发出请求</li>
<li>服务器监听到端口有请求过来</li>
<li>根据服务器的路由配置，返回相应信息（可以是html、json、图片等）</li>
<li>浏览器根据数据包的<code>Context-Type</code>来决定如何解析</li>
</ol>
<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><p>随着<code>ajax</code>的流行，异步数据请求交互在不刷新浏览器的情况下运行。而异步交互体验的高级版本就是SPA-单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。类似于后端路由，前端路由就是匹配不同的url路径进行解析，然后动态渲染html内容。</p>
<h3 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h3><p><code>https://www.xxx.com/#/hash</code></p>
<p>这种<code>#</code>后面<code>hash</code>值得变化，并不会触发新的请求，因此也不会刷新页面。每次<code>hash</code>值的变化都会触发<code>hashchange</code>事件，通过这个事件就可以知道更新哪些页面内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.oldURL, e.newURL)</span><br><span class="line">    <span class="keyword">const</span> hash = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">    app.innerHTML = hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h3><p><code>https://www.xxx.com/login</code></p>
<p>随着HTML5的发布，带来了两个新的API：<code>pushState</code>和<code>replaceState</code>，通过这两个API可以改变url地址且不会发送请求。同时还有<code>popstate</code>事件用来监听url的改变。使用history模式，url就不会出现丑陋的<code>#</code>，url也变得比较美观。</p>
<p>通过history api去掉了丑陋的<code>#</code>，但也存在问题：不怕前进/后退，就怕<strong>刷新</strong>。因为刷新是去请求服务器的，在<code>hash</code>下，前端路由修改的是#之后的内容，在发送请求时是不会带上的，但在history下可以自由地修改路径、参数，当刷新时，如果服务器中没有相应的响应或资源，容易爆<code>404</code></p>
<h2 id="vue-router核心原理"><a href="#vue-router核心原理" class="headerlink" title="vue-router核心原理"></a>vue-router核心原理</h2><ol>
<li><p>通过<code>new VueRouter</code>中的<code>mode</code>参数来选择使用那种路由模式</p>
</li>
<li><p>在<code>router</code>中使用<code>current</code>保存当前url</p>
</li>
<li><p>作为一个插件，大部分功能都在<code>install</code>函数中完成</p>
</li>
<li><p>在<code>install</code>中使用<code>Vue.mixin</code>注入的<code>beforeCreate</code>来给组件添加全局唯一的<code>router</code>实例（挂载在根组件上，其余组件通过<code>$parent._routerRoot._router</code>挂载）</p>
</li>
<li><p>使用<code>popstate</code>或<code>hashchange</code>两个事件来监听url变化（针对于手动输入url）并设置<code>current</code></p>
</li>
<li><p>使用<code>Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)</code>来使<code>router</code>变为响应式</p>
<p>current变化    👉    重新渲染<code>router-view</code>中的组件 </p>
</li>
<li><p>解析路由配置从而可以更加便利地找到url所对应的页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>&lt;&#123; <span class="attr">name</span>: component &#125;&gt;</span><br></pre></td></tr></table></figure>

<p>👇</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;&#123; <span class="attr">name</span>: component &#125;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>&lt;router-link&gt;&lt;/router-link&gt;</code>和<code>&lt;router-view / &gt;</code>两个组件</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>vue-router</code>以插件方式侵入<code>Vue</code>，从而支持一个额外的<code>router</code>属性，以提供监听并改变组件路由数据的能力，这样每次路由发生变化后，可以同步到数据，从而响应式地触发组件的更新</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-router.png" alt="vue-router"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/06/Vue.js研读-生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/06/Vue.js研读-生命周期/" class="post-title-link" itemprop="url">Vue.js研读-生命周期</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-06 23:29:53" itemprop="dateCreated datePublished" datetime="2020-03-06T23:29:53+08:00">2020-03-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-21 22:35:17" itemprop="dateModified" datetime="2020-04-21T22:35:17+08:00">2020-04-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="生命周期概览"><a href="#生命周期概览" class="headerlink" title="生命周期概览"></a>生命周期概览</h2><p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/lifecycle.png" alt="生命周期"></p>
<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul>
<li><p>beforeCreate</p>
<p><code>new Vue()</code>之后触发的第一个钩子，在当前阶段<code>data</code>、methods、<code>computed</code>以及watch上的数据和方法均不能被访问</p>
</li>
<li><p>created</p>
<p>在实例创建完成之后触发，当前阶段已完成了数据观测，也就是可以使用数据，更改数据，在这个更改数据不会触发<code>updated</code>函数。可以做一些<strong>初始数据的获取</strong>，在当前阶段无法获取DOM（可使用vm.$nextTick）</p>
</li>
<li><p>beforeMounte</p>
<p>发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟DOM已创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发<code>updated</code></p>
</li>
<li><p>mounted</p>
<p>在挂载之后被触发。在当前阶段，真实的DOM被挂载完毕，数据完成双向绑定，可以访问到DOM阶段，使用$ref属性对DOM进行操作</p>
</li>
<li><p>beforeUpdate</p>
<p>在界面发生更新之前被触发。也就是响应式数据发生改变之前、虚拟DOM重新渲染之前被触发，可以在此阶段进行更改数据，不会造成重渲染</p>
</li>
<li><p>updated</p>
<p>在发生更新之后被触发。当前阶段DOM已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</p>
</li>
<li><p>beforeDestory</p>
<p>在实例被销毁之前触发。在当前阶段实例完全可以被使用，可以在此阶段做些善后工作，如清除定时器</p>
</li>
<li><p>destoryed</p>
<p>在实例被销毁之后触发。这个时候只剩下DOM，组件已被拆解，数据绑定被卸载、监听被移除、子实例也统统被销毁</p>
</li>
</ul>
<h2 id="组件的生命周期函数调用顺序"><a href="#组件的生命周期函数调用顺序" class="headerlink" title="组件的生命周期函数调用顺序"></a>组件的生命周期函数调用顺序</h2><ul>
<li><p>加载渲染顺序</p>
<p>父beforeCreate👉父created👉父beforeMmount👉子beforeCreate👉子created👉子beforeMount👉子mounted👉父mounted</p>
</li>
<li><p>更新顺序</p>
<p>父beforeUpdate👉子beforeUpdate👉子updated👉父updated</p>
</li>
<li><p>销毁顺序</p>
<p>父beforeDestory👉子beforeDestory👉子destoryed👉父destoryed</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/05/Vue.js研读-模板编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/05/Vue.js研读-模板编译/" class="post-title-link" itemprop="url">Vue.js研读-模板编译</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-05 22:54:17" itemprop="dateCreated datePublished" datetime="2020-03-05T22:54:17+08:00">2020-03-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-21 22:35:22" itemprop="dateModified" datetime="2020-04-21T22:35:22+08:00">2020-04-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><p>模板编译的主要目标是<strong>生成渲染函数</strong>。而渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的vnode，然后使用这份vnode进行渲染。</p>
<h2 id="将模板编译成渲染函数"><a href="#将模板编译成渲染函数" class="headerlink" title="将模板编译成渲染函数"></a>将模板编译成渲染函数</h2><ul>
<li><p>将模板编译成AST（解析器）</p>
</li>
<li><p>遍历AST标记静态节点（优化器）</p>
</li>
<li><p>使用AST生成渲染函数（代码生成器）</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-0.png" alt="模板编译整体流程"></p>
</li>
</ul>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>将模板编译成AST</p>
<p>在解析器内部，分成了很多小解析器，其中包括过滤解析器、文本解析器和HTML解析器。然后再通过一条主线将这些解析器组装在一起。</p>
<p>HTML解析器是解析器中最核心的模块，它的作用是解析HTML模板，每当解析到HTML标签的开始位置、结束位置、文本或注释时，都会<strong>触发钩子函数</strong>，然后将相关信息通过参数传递出来。在解析期间，使用栈来记录层级关系（触发start钩子函数时入栈，触发end钩子函数时出栈）。</p>
<p>事实上，解析HTML模板的过程就是循环的过程，简单来说就是用HTML模板字符串来循环，每轮循环都从HTML模板中截取一小段字符串，然后重复上述过程👆，直到HTML模板被截成一个空字符串时结束。</p>
<p>文本解析器的主要作用是对HTML解析器解析出来的文本进行二次加工，处理<strong>带变量</strong>的文本。HTML解析器在解析文本时并不会区分文本是否是带有变量的文本，如果是纯文本，不需要进行任何处理；但如果是带变量的文本那个需要使用文本解析器进一步解析。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器的目标是遍历AST，检测出所有静态子树（永远不会变化的DOM节点）并给其打标记</p>
<p>标记静态子树有两点好处：</p>
<ul>
<li>每次重新渲染时，不需要为静态子树创建新节点</li>
<li>在虚拟DOM中打补丁的过程中可以跳过</li>
</ul>
<p>优化器内部实现主要有以下两个步骤：</p>
<ol>
<li><p>在AST中找出所有静态节点并打上标记（<code>static === true</code>）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个静态节点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在AST中供找出所有静态根节点并打上标记（<code>staticRoot === true</code>）</p>
<p>如果一个节点下边的所有<strong>子节点都是静态节点</strong>，并且它的<strong>父级是动态节点</strong>，那么它就是静态根节点</p>
</li>
</ol>
<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>代码生成器是模板编译的最后一步，它的作用是将AST转换成渲染函数中的内容，这个内容称为<strong>代码字符串</strong>。之后交由渲染函数导出到外界。</p>
<p>代码生成器其实就是字符串拼接的过程。通过递归AST来生成字符串，最先生成根节点，然后在子节点字符串生成后，将其拼接在根节点的参数中，子节点的子节点拼接在子节点的参数中，这样一层一层地拼接，直到最后拼接成完整的字符串。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/04/Vue.js研读-虚拟DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/04/Vue.js研读-虚拟DOM/" class="post-title-link" itemprop="url">Vue.js研读-虚拟DOM</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-04 23:18:13" itemprop="dateCreated datePublished" datetime="2020-03-04T23:18:13+08:00">2020-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-22 22:02:33" itemprop="dateModified" datetime="2020-04-22T22:02:33+08:00">2020-04-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Vue-js为什么要引入虚拟DOM"><a href="#Vue-js为什么要引入虚拟DOM" class="headerlink" title="Vue.js为什么要引入虚拟DOM"></a>Vue.js为什么要引入虚拟DOM</h2><p>虚拟DOM是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上次生成的虚拟节点树进行对比，只渲染不同的部分</p>
<p>在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对（Vue.js 1.0）。但这样做缺点很明显：因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及依赖追踪的开销。当状态被越来越多的节点使用时，开销就越大。</p>
<p>因此Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入虚拟DOM。组件级别是一个watcher实例。就是说即使一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对渲染，这是一个折中方案</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-0.png" alt="虚拟DOM"></p>
<h2 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h2><p>vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后再插入到页面渲染视图</p>
<p>vnode的类型包括：注释节点(isComment=true)、文本节点、元素节点(具有tag属性)、组件节点、函数式组件、克隆节点</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-1.png" alt="虚拟DOM"></p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>对比两个vnode之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的是修改DOM节点，也可以理解为渲染视图。包括：创建新增的节点、删除已经废弃的节点、修改需要更新的节点</p>
<p>path的核心算法diff是通过<strong>同层</strong>的树节点进行比较而非对树进行逐层遍历的方式，所以时间复杂度只有O(n)</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/patch-0.png" alt></p>
<ul>
<li><p>创建新节点</p>
<p>事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点、文本节点</p>
<ul>
<li>oldVnode中不存在而vnode中存在</li>
<li>oldVnode和vnode完全不是同一个节点</li>
</ul>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-2.png" alt="创建节点"></p>
</li>
<li><p>删除节点</p>
<p>某个节点只在oldVnode中存在</p>
</li>
<li><p>更新节点</p>
<p>oldVnode和vnode相同（通过sameVnode判断）</p>
<p>判断依据：key、tag、isComment、data、input的type均相同</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-3.png" alt="更新节点"></p>
</li>
</ul>
<h2 id="DOM-Diff过程"><a href="#DOM-Diff过程" class="headerlink" title="DOM Diff过程"></a>DOM Diff过程</h2><p>简单来说，diff有以下过程：</p>
<ol>
<li>同级比较，再比较子节点</li>
<li>先判断一方有子节点而另一方没有子节点的情况</li>
<li>比较都有子节点的情况（核心diff算法）</li>
<li>递归比较子节点</li>
</ol>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-0.png" alt="diff过程"></p>
<h2 id="核心DIFF算法"><a href="#核心DIFF算法" class="headerlink" title="核心DIFF算法"></a>核心DIFF算法</h2><p>Vue2.0采用了<strong>双端比较</strong>的算法：同时从新旧children的两端开始进行比较，借助key值可以找到可复用的节点，再进行相关操作。<br><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-1.png" alt="diff-1"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/03/Vue.js研读-响应式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/03/Vue.js研读-响应式/" class="post-title-link" itemprop="url">Vue.js研读-响应式</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-03 23:15:13" itemprop="dateCreated datePublished" datetime="2020-03-03T23:15:13+08:00">2020-03-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-21 22:35:13" itemprop="dateModified" datetime="2020-04-21T22:35:13+08:00">2020-04-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-1.png" alt="响应式管理"></p>
<p>Data通过<code>Observer</code>转换成了<strong>getter/setter</strong>的形式类追踪变化</p>
<p>当外界通过<code>Watcher</code>读取数据（Compile时会根据<strong>{}</strong>、<strong>v-*</strong>来创建Watcher）时会触发getter从而将Watcher添加到依赖中</p>
<p>当数据发生变化时，会触发setter，从而向<code>Dep</code>中的依赖（Watcher）发送通知</p>
<p>Wacher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数</p>
<h2 id="简易版响应式（Proxy-Observer-Watcher-Dep）"><a href="#简易版响应式（Proxy-Observer-Watcher-Dep）" class="headerlink" title="简易版响应式（Proxy + Observer/Watcher/Dep）"></a>简易版响应式（Proxy + Observer/Watcher/Dep）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">obj, path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path === <span class="string">""</span>) <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> path.split(<span class="string">"."</span>).reduce(<span class="function">(<span class="params">data, current</span>) =&gt;</span> data[current], obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">"object"</span>) <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">        <span class="keyword">set</span>: (target, prop, value, receiver) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> oldVal = target[prop]</span><br><span class="line">            <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, prop, defineReactive(value), receiver)</span><br><span class="line">            <span class="keyword">if</span> (oldVal !== value) dep.notify()</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>: (target, prop, receiver) =&gt; &#123;</span><br><span class="line">            dep.depend()</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (vm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> vm !== <span class="string">"object"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"vm must be an object"</span>)</span><br><span class="line">        <span class="keyword">this</span>.walk(vm)</span><br><span class="line">        <span class="keyword">return</span> defineReactive(vm)</span><br><span class="line">    &#125;</span><br><span class="line">    walk (vm) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(vm).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> vm[item] === <span class="string">"object"</span>) <span class="keyword">this</span>.walk(vm[item])</span><br><span class="line">            vm[item] = defineReactive(vm[item])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = uid++</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    depend () &#123;</span><br><span class="line">        Dep.target &amp;&amp; Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.slice().forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.update())</span><br><span class="line">    &#125;</span><br><span class="line">    removeSub (sub) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.subs.indexOf(sub)</span><br><span class="line">        index &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.subs.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (vm, exp, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm</span><br><span class="line">        <span class="keyword">this</span>.exp = exp</span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line">        <span class="keyword">this</span>.deps = []</span><br><span class="line">        <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">        Dep.target = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">let</span> value = parsePath(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.exp)</span><br><span class="line">        Dep.target = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    update () &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">    addDep (dep) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.depIds.has(dep.id)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">this</span>.depIds.add(dep.id)</span><br><span class="line">        <span class="keyword">this</span>.deps.push(dep)</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    teardown () &#123;</span><br><span class="line">        <span class="keyword">this</span>.deps.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.removeSub(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">vm, exp, cb, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, exp, cb)</span><br><span class="line">    <span class="keyword">if</span> (options.immediate) cb.call(vm, watcher.value)</span><br><span class="line">    <span class="keyword">return</span> watcher.teardown.bind(watcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; Observer, watch &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./mvvm.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = <span class="keyword">new</span> Observer(&#123;</span></span><br><span class="line">        student: &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">"tom"</span>,</span></span><br><span class="line">            age: 23</span><br><span class="line">        &#125;,</span><br><span class="line">        address: &#123;</span><br><span class="line">            province: &#123;</span><br><span class="line">                id: 41,</span><br><span class="line"><span class="javascript">                view: <span class="string">"河南"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        friends: [ <span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span> ],</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"student"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student'</span>, val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"student.name"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student.name'</span>, val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"student.age"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student.age'</span>, val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"address.province.id"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"update address.province.id"</span>, val);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"friends.length"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student.friends'</span>, data.friends[val - <span class="number">1</span>]);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> unwatch = watch(data, <span class="string">"address.province.view"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'address.province.view'</span>, val);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="$vm.watch(expOrFn, callback, [options])"></a>$vm.watch(expOrFn, callback, [options])</h2><p>用于观察一个表达式或computed函数在Vue.js实例上的变化。回调函数调用时，会从参数中得到oldValue和newValue</p>
<p>vm.$watch其实是对Watcher的一种封装，没有缓存性，通过Watcher完全可以实现vm.$watch的功能</p>
<ol>
<li>先执行new Watcher来实现vm.$watch的基本功能</li>
<li>判断用户是否使用immediate参数，如果使用了则立即执行一次cb</li>
<li>判断用户是否使用deep参数，如果使用除了要触发当前这个被监听数据的依赖收集的逻辑之外，还要把当前监听的这个值在内的所有子值都要触发一遍依赖收集逻辑</li>
<li>返回一个函数unwatchFn，用于取消观察数据</li>
</ol>
<h2 id="vm-computed"><a href="#vm-computed" class="headerlink" title="$vm.computed"></a>$vm.computed</h2><p><code>computed</code>是定义在<code>vm</code>上的一个特殊的<code>getter</code>方法。之所以说特殊是因为在vm上定义<code>getter</code>方法时，<code>get</code>并不是由用户提供的函数，而是Vue.js内部的一个代理函数。在代理函数中可以结合<code>Watcher</code>实现缓存与收集依赖等功能。在模板中使用一个数据渲染视图时，如果这个数据恰好是计算属性，那么读取数据这个操作其实会触发计算属性的<code>getter</code>方法。</p>
<p>当这个getter方法被触发时会做两件事：</p>
<ol>
<li>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false，这样再次读取计算属性时将不再重新计算，除非计算属性所依赖的值发生了变化</li>
<li>当计算属性中用到的树发生变化时，将得到通知从而进行重新渲染操作</li>
</ol>
<p>我们知道计算属性的结果会被缓存，且只有在计算属性所依赖的响应式属性或者计算属性的返回值发生变化时才会重新计算。这是结合<code>Watcher</code>的<code>dirty</code>属性来分辨的：当<code>dirty===true</code>时，说明需要重新计算“计算属性”的返回值；当计算属性中的内容发生变化后，计算属性的<code>Watcher</code>与组件的<code>Watcher</code>都会得到通知。计算属性的<code>Watcher</code>会将自己的<code>dirty</code>属性设置为true，当下一次读取计算属性时就会重新计算一次值。与此同时组件的<code>Watcher</code>也会得到通知，从而执行render函数进行重新渲染的操作。由于要重新执行<code>render</code>函数，所以会重新读取计算属性的值，这时候计算属性的Watcher已经把自己的<code>dirty</code>置为<code>true</code>，所以会重新计算一次计算属性的值用于本次渲染</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/computed-0.png" alt="computed原理0"></p>
<p>这种方式实现的computed有一个弊端：只是观察它所用到的数据是否发生了变化，并<strong>没有真正去校验它自身的返回值是否有变化</strong>，所以当它所使用的数据发生变化后，组件<strong>总会重新走一遍渲染流程</strong>。</p>
<p>为解决这个问题，新版计算属性做了一些改动：组件的Watcher不再观察计算属性用到的数据的变化，而是让计算属性的Watcher得到通知后计算一次计算属性的值，如果发现这一次计算属性的值与上一次计算出来的值不一样，再去主动通知组件的Watcher进行重新渲染操作。</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/computed-1.png" alt="computed原理1"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/imgs/avatar.png"
      alt="Mr.RS">
  <p class="site-author-name" itemprop="name">Mr.RS</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.RS</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>
