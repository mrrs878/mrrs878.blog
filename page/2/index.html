<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png?v=7.4.1">
  <link rel="mask-icon" href="/images/avatar.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Mr.RS">
<meta property="og:url" content="https://mrrs878.github.io/page/2/index.html">
<meta property="og:site_name" content="Mr.RS">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.RS">
  <link rel="canonical" href="https://mrrs878.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Mr.RS</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.RS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Read The Fucking Source Code!</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      
    
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/05/Vue.js研读-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/05/Vue.js研读-3/" class="post-title-link" itemprop="url">Vue.js研读-3</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-05 22:54:17" itemprop="dateCreated datePublished" datetime="2020-03-05T22:54:17+08:00">2020-03-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-11 11:17:01" itemprop="dateModified" datetime="2020-03-11T11:17:01+08:00">2020-03-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><p>模板编译的主要目标是<strong>生成渲染函数</strong>。而渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的vnode，然后使用这份vnode进行渲染。</p>
<h2 id="将模板编译成渲染函数"><a href="#将模板编译成渲染函数" class="headerlink" title="将模板编译成渲染函数"></a>将模板编译成渲染函数</h2><ul>
<li><p>将模板编译成AST（解析器）</p>
</li>
<li><p>遍历AST标记静态节点（优化器）</p>
</li>
<li><p>使用AST生成渲染函数（代码生成器）</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-0.png" alt="模板编译整体流程"></p>
</li>
</ul>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>将模板编译成AST</p>
<p>在解析器内部，分成了很多小解析器，其中包括过滤解析器、文本解析器和HTML解析器。然后再通过一条主线将这些解析器组装在一起。</p>
<p>HTML解析器是解析器中最核心的模块，它的作用是解析HTML模板，每当解析到HTML标签的开始位置、结束位置、文本或注释时，都会<strong>触发钩子函数</strong>，然后将相关信息通过参数传递出来。在解析期间，使用栈来记录层级关系（触发start钩子函数时入栈，触发end钩子函数时出栈）。</p>
<p>事实上，解析HTML模板的过程就是循环的过程，简单来说就是用HTML模板字符串来循环，每轮循环都从HTML模板中截取一小段字符串，然后重复上述过程👆，直到HTML模板被截成一个空字符串时结束。</p>
<p>文本解析器的主要作用是对HTML解析器解析出来的文本进行二次加工，处理<strong>带变量</strong>的文本。HTML解析器在解析文本时并不会区分文本是否是带有变量的文本，如果是纯文本，不需要进行任何处理；但如果是带变量的文本那个需要使用文本解析器进一步解析。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器的目标是遍历AST，检测出所有静态子树（永远不会变化的DOM节点）并给其打标记</p>
<p>标记静态子树有两点好处：</p>
<ul>
<li>每次重新渲染时，不需要为静态子树创建新节点</li>
<li>在虚拟DOM中打补丁的过程中可以跳过</li>
</ul>
<p>优化器内部实现主要有以下两个步骤：</p>
<ol>
<li><p>在AST中找出所有静态节点并打上标记（<code>static === true</code>）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个静态节点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在AST中供找出所有静态根节点并打上标记（<code>staticRoot === true</code>）</p>
<p>如果一个节点下边的所有<strong>子节点都是静态节点</strong>，并且它的<strong>父级是动态节点</strong>，那么它就是静态根节点</p>
</li>
</ol>
<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>代码生成器是模板编译的最后一步，它的作用是将AST转换成渲染函数中的内容，这个内容称为<strong>代码字符串</strong>。之后交由渲染函数导出到外界。</p>
<p>代码生成器其实就是字符串拼接的过程。通过递归AST来生成字符串，最先生成根节点，然后在子节点字符串生成后，将其拼接在根节点的参数中，子节点的子节点拼接在子节点的参数中，这样一层一层地拼接，直到最后拼接成完整的字符串。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/04/Vue.js研读-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/04/Vue.js研读-2/" class="post-title-link" itemprop="url">Vue.js研读-2</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-04 23:18:13" itemprop="dateCreated datePublished" datetime="2020-03-04T23:18:13+08:00">2020-03-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-11 16:23:19" itemprop="dateModified" datetime="2020-03-11T16:23:19+08:00">2020-03-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Vue-js为什么要引入虚拟DOM"><a href="#Vue-js为什么要引入虚拟DOM" class="headerlink" title="Vue.js为什么要引入虚拟DOM"></a>Vue.js为什么要引入虚拟DOM</h2><p>虚拟DOM是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上次生成的虚拟节点树进行对比，只渲染不同的部分</p>
<p>在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对（Vue.js 1.0）。但这样做缺点很明显：因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及依赖追踪的开销。当状态被越来越多的节点使用时，开销就越大。</p>
<p>因此Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入虚拟DOM。组件级别是一个watcher实例。就是说即使一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对渲染，这是一个折中方案</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-0.png" alt="虚拟DOM"></p>
<h2 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h2><p>vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后再插入到页面渲染视图</p>
<p>vnode的类型包括：注释节点(isComment=true)、文本节点、元素节点(具有tag属性)、组件节点、函数式组件、克隆节点</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-1.png" alt="虚拟DOM"></p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>对比两个vnode之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的是修改DOM节点，也可以理解为渲染视图。包括：创建新增的节点、删除已经废弃的节点、修改需要更新的节点</p>
<p>path的核心算法diff是通过<strong>同层</strong>的树节点进行比较而非对树进行逐层遍历的方式，所以时间复杂度只有O(n)</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/patch-0.png" alt></p>
<ul>
<li><p>创建新节点</p>
<p>事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点、文本节点</p>
<ul>
<li>oldVnode中不存在而vnode中存在</li>
<li>oldVnode和vnode完全不是同一个节点</li>
</ul>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-2.png" alt="创建节点"></p>
</li>
<li><p>删除节点</p>
<p>某个节点只在oldVnode中存在</p>
</li>
<li><p>更新节点</p>
<p>oldVnode和vnode相同（通过sameVnode判断）</p>
<p>判断依据：key、tag、isComment、data、input的type均相同</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-3.png" alt="更新节点"></p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/03/Vue.js研读-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/03/Vue.js研读-1/" class="post-title-link" itemprop="url">Vue.js研读-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-03 23:15:13" itemprop="dateCreated datePublished" datetime="2020-03-03T23:15:13+08:00">2020-03-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-11 16:14:17" itemprop="dateModified" datetime="2020-03-11T16:14:17+08:00">2020-03-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-1.png" alt="响应式管理"></p>
<p>Data通过<code>Observer</code>转换成了<strong>getter/setter</strong>的形式类追踪变化</p>
<p>当外界通过<code>Watcher</code>读取数据（Compile时会根据<strong>{}</strong>、<strong>v-*</strong>来创建Watcher）时会触发getter从而将Watcher添加到依赖中</p>
<p>当数据发生变化时，会触发setter，从而向<code>Dep</code>中的依赖（Watcher）发送通知</p>
<p>Wacher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数</p>
<h2 id="简易版响应式（Proxy-Observer-Watcher-Dep）"><a href="#简易版响应式（Proxy-Observer-Watcher-Dep）" class="headerlink" title="简易版响应式（Proxy + Observer/Watcher/Dep）"></a>简易版响应式（Proxy + Observer/Watcher/Dep）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">obj, path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path === <span class="string">""</span>) <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">return</span> path.split(<span class="string">"."</span>).reduce(<span class="function">(<span class="params">data, current</span>) =&gt;</span> data[current], obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">"object"</span>) <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">        <span class="keyword">set</span>: (target, prop, value, receiver) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> oldVal = target[prop]</span><br><span class="line">            <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, prop, defineReactive(value), receiver)</span><br><span class="line">            <span class="keyword">if</span> (oldVal !== value) dep.notify()</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>: (target, prop, receiver) =&gt; &#123;</span><br><span class="line">            dep.depend()</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (vm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> vm !== <span class="string">"object"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"vm must be an object"</span>)</span><br><span class="line">        <span class="keyword">this</span>.walk(vm)</span><br><span class="line">        <span class="keyword">return</span> defineReactive(vm)</span><br><span class="line">    &#125;</span><br><span class="line">    walk (vm) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(vm).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> vm[item] === <span class="string">"object"</span>) <span class="keyword">this</span>.walk(vm[item])</span><br><span class="line">            vm[item] = defineReactive(vm[item])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = uid++</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    depend () &#123;</span><br><span class="line">        Dep.target &amp;&amp; Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.slice().forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.update())</span><br><span class="line">    &#125;</span><br><span class="line">    removeSub (sub) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.subs.indexOf(sub)</span><br><span class="line">        index &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.subs.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (vm, exp, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm</span><br><span class="line">        <span class="keyword">this</span>.exp = exp</span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line">        <span class="keyword">this</span>.deps = []</span><br><span class="line">        <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">        Dep.target = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">let</span> value = parsePath(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.exp)</span><br><span class="line">        Dep.target = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    update () &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">    addDep (dep) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.depIds.has(dep.id)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">this</span>.depIds.add(dep.id)</span><br><span class="line">        <span class="keyword">this</span>.deps.push(dep)</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    teardown () &#123;</span><br><span class="line">        <span class="keyword">this</span>.deps.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.removeSub(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">vm, exp, cb, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, exp, cb)</span><br><span class="line">    <span class="keyword">if</span> (options.immediate) cb.call(vm, watcher.value)</span><br><span class="line">    <span class="keyword">return</span> watcher.teardown.bind(watcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; Observer, watch &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./mvvm.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = <span class="keyword">new</span> Observer(&#123;</span></span><br><span class="line">        student: &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">"tom"</span>,</span></span><br><span class="line">            age: 23</span><br><span class="line">        &#125;,</span><br><span class="line">        address: &#123;</span><br><span class="line">            province: &#123;</span><br><span class="line">                id: 41,</span><br><span class="line"><span class="javascript">                view: <span class="string">"河南"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        friends: [ <span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span> ],</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"student"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student'</span>, val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"student.name"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student.name'</span>, val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"student.age"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student.age'</span>, val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"address.province.id"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"update address.province.id"</span>, val);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(data, <span class="string">"friends.length"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'update student.friends'</span>, data.friends[val - <span class="number">1</span>]);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> unwatch = watch(data, <span class="string">"address.province.view"</span>, val =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'address.province.view'</span>, val);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="vm-watch-expOrFn-callback-options"><a href="#vm-watch-expOrFn-callback-options" class="headerlink" title="$vm.watch(expOrFn, callback, [options])"></a>$vm.watch(expOrFn, callback, [options])</h2><p>用于观察一个表达式或computed函数在Vue.js实例上的变化。回调函数调用时，会从参数中得到oldValue和newValue</p>
<p>vm.$watch其实是对Watcher的一种封装，没有缓存性，通过Watcher完全可以实现vm.$watch的功能</p>
<ol>
<li>先执行new Watcher来实现vm.$watch的基本功能</li>
<li>判断用户是否使用immediate参数，如果使用了则立即执行一次cb</li>
<li>判断用户是否使用deep参数，如果使用除了要触发当前这个被监听数据的依赖收集的逻辑之外，还要把当前监听的这个值在内的所有子值都要触发一遍依赖收集逻辑</li>
<li>返回一个函数unwatchFn，用于取消观察数据</li>
</ol>
<h2 id="vm-computed"><a href="#vm-computed" class="headerlink" title="$vm.computed"></a>$vm.computed</h2><p><code>computed</code>是定义在<code>vm</code>上的一个特殊的<code>getter</code>方法。之所以说特殊是因为在vm上定义<code>getter</code>方法时，<code>get</code>并不是由用户提供的函数，而是Vue.js内部的一个代理函数。在代理函数中可以结合<code>Watcher</code>实现缓存与收集依赖等功能。在模板中使用一个数据渲染视图时，如果这个数据恰好是计算属性，那么读取数据这个操作其实会触发计算属性的<code>getter</code>方法。</p>
<p>当这个getter方法被触发时会做两件事：</p>
<ol>
<li>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false，这样再次读取计算属性时将不再重新计算，除非计算属性所依赖的值发生了变化</li>
<li>当计算属性中用到的树发生变化时，将得到通知从而进行重新渲染操作</li>
</ol>
<p>我们知道计算属性的结果会被缓存，且只有在计算属性所依赖的响应式属性或者计算属性的返回值发生变化时才会重新计算。这是结合<code>Watcher</code>的<code>dirty</code>属性来分辨的：当<code>dirty===true</code>时，说明需要重新计算“计算属性”的返回值；当计算属性中的内容发生变化后，计算属性的<code>Watcher</code>与组件的<code>Watcher</code>都会得到通知。计算属性的<code>Watcher</code>会将自己的<code>dirty</code>属性设置为true，当下一次读取计算属性时就会重新计算一次值。与此同时组件的<code>Watcher</code>也会得到通知，从而执行render函数进行重新渲染的操作。由于要重新执行<code>render</code>函数，所以会重新读取计算属性的值，这时候计算属性的Watcher已经把自己的<code>dirty</code>置为<code>true</code>，所以会重新计算一次计算属性的值用于本次渲染</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/computed-0.png" alt="computed原理0"></p>
<p>这种方式实现的computed有一个弊端：只是观察它所用到的数据是否发生了变化，并<strong>没有真正去校验它自身的返回值是否有变化</strong>，所以当它所使用的数据发生变化后，组件<strong>总会重新走一遍渲染流程</strong>。</p>
<p>为解决这个问题，新版计算属性做了一些改动：组件的Watcher不再观察计算属性用到的数据的变化，而是让计算属性的Watcher得到通知后计算一次计算属性的值，如果发现这一次计算属性的值与上一次计算出来的值不一样，再去主动通知组件的Watcher进行重新渲染操作。</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/computed-1.png" alt="computed原理1"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/02/Vue.js研读-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/02/Vue.js研读-0/" class="post-title-link" itemprop="url">Vue.js研读-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-02 23:21:38" itemprop="dateCreated datePublished" datetime="2020-03-02T23:21:38+08:00">2020-03-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-11 17:40:10" itemprop="dateModified" datetime="2020-03-11T17:40:10+08:00">2020-03-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Document-createDocumentFragment"><a href="#Document-createDocumentFragment" class="headerlink" title="Document.createDocumentFragment()"></a>Document.createDocumentFragment()</h2><p><code>DocumentFragments</code> 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。</p>
<p>因为文档片段存在于<strong>内存中</strong>，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow" target="_blank" rel="noopener">回流</a>（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</p>
<h2 id="node-nodeType"><a href="#node-nodeType" class="headerlink" title="node.nodeType"></a>node.nodeType</h2><p>1 元素</p>
<p>2 属性</p>
<p>3 文本</p>
<p>8 注释</p>
<p>9 document</p>
<h2 id="node-textContext、node-innerText"><a href="#node-textContext、node-innerText" class="headerlink" title="node.textContext、node.innerText"></a>node.textContext、node.innerText</h2><p><code>textContent</code>会获取所有元素的内容，包括<code>script</code>和<code>style</code>元素。然而<code>innerText</code>只展示给人看的元素</p>
<p><code>textContext</code>会返回节点中的每一个元素，相反，<code>innerText</code>受<code>CSS</code>样式的影响，不会返回隐藏元素的文本，并且会触发<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow" target="_blank" rel="noopener">回流</a>去确保是最新的计算样式</p>
<p>与<code>textContext</code>不同的是，在IE11以及下版本中，对<code>innerText</code>进行修改，不仅会移除当前元素的子节点，而且会永久性的破坏所有后代文本节点，在之后不可能再次将节点到任何其他元素或同同一元素</p>
<h2 id="通过字符串路径获取对象属性的简单方法（暂不支持-）"><a href="#通过字符串路径获取对象属性的简单方法（暂不支持-）" class="headerlink" title="通过字符串路径获取对象属性的简单方法（暂不支持[]）"></a>通过字符串路径获取对象属性的简单方法（暂不支持[]）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">obj, path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.split(<span class="string">"."</span>).reduce(<span class="function">(<span class="params">data, current</span>) =&gt;</span> data[current], obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    tom: &#123;</span><br><span class="line">        name: <span class="string">"tom"</span>,</span><br><span class="line">        age: <span class="number">23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = parsePath(obj1, <span class="string">"tom.name"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// tom</span></span><br></pre></td></tr></table></figure>

<h2 id="e-target和e-currentTarget"><a href="#e-target和e-currentTarget" class="headerlink" title="e.target和e.currentTarget"></a>e.target和e.currentTarget</h2><p>e.target指向触发事件的对象</p>
<p>e.currentTarget指向添加监听事件的对象</p>
<h2 id="Vue-js整体流程"><a href="#Vue-js整体流程" class="headerlink" title="Vue.js整体流程"></a>Vue.js整体流程</h2><p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-4.png" alt="Vue.js整体流程"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/19/ES6重点-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/19/ES6重点-1/" class="post-title-link" itemprop="url">ES6重点-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-19 23:01:48" itemprop="dateCreated datePublished" datetime="2020-02-19T23:01:48+08:00">2020-02-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-29 23:01:30" itemprop="dateModified" datetime="2020-02-29T23:01:30+08:00">2020-02-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符串新增方法"><a href="#字符串新增方法" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h2><ul>
<li><p><code>padStart</code></p>
<p>用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>)); <span class="comment">//补全位数，有需要会重复或截取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padStart(<span class="number">4</span>)); <span class="comment">// 不传第二个参数默认使用空格补全</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padStart(<span class="number">2</span>)); <span class="comment">// 补全后的长度小于源字符串长度则不做任何改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// abax</span></span><br><span class="line"><span class="comment">// axxx</span></span><br><span class="line"><span class="comment">//    x</span></span><br><span class="line"><span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>padEnd</code></p>
<p>和<code>padStart</code>效果相反，从尾部开始补全</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'abc'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padEnd(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padEnd(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// xabca</span></span><br><span class="line"><span class="comment">// x   </span></span><br><span class="line"><span class="comment">// xxx</span></span><br><span class="line"><span class="comment">// xxxa</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对象新增扩展"><a href="#对象新增扩展" class="headerlink" title="对象新增扩展"></a>对象新增扩展</h2><ul>
<li><p>链判断运算符</p>
<p>在ES5中，取对象属性时，往往需要判断以下该对象是否存在。如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = (store </span><br><span class="line">    &amp;&amp; store.state </span><br><span class="line">    &amp;&amp; store.state.user </span><br><span class="line">    &amp;&amp; store.state.user.name) || <span class="string">"tom"</span></span><br></pre></td></tr></table></figure>

<p>这种层层判断过于麻烦，因此ES2020引入链判断运算符<code>?.</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = store?.state?.user?.name</span><br></pre></td></tr></table></figure>

<p>如果左侧的对象为<code>null</code>或<code>undefined</code>则直接返回<code>undefined</code>，不再往下运算</p>
</li>
<li><p><code>null</code>判断运算符</p>
<p>独去对象属性时，如果某个属性的值时<code>null</code>或<code>undefined</code>，有时需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = user.name || <span class="string">"tom"</span></span><br><span class="line"><span class="keyword">const</span> age = user.age || <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>原意是属性值为<code>null</code>或<code>undefined</code>时默认值就生效，但当<code>user.name</code>为空串或<code>user.age</code>为0时默认值也会生效</p>
<p>为此ES2020引入新的<code>null</code>判断运算符<code>??</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = user.name ?? <span class="string">"tom"</span></span><br><span class="line"><span class="keyword">const</span> age = user.age ?? <span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h2><ul>
<li><p><code>Object.is</code></p>
<p>用来替代 <code>==</code>和<code>===</code></p>
<p><code>==</code> 会进行自动类型转换，<code>===</code> 在比较+0和-0时返回<code>true</code>，<code>NaN</code>不等于自身</p>
</li>
<li><p><code>Object.assign</code></p>
<p>用于对象合并</p>
<ul>
<li>只拷贝源对象的<strong>自身、可枚举属性（含Symbol）</strong></li>
<li>浅拷贝</li>
<li>同名属性会被覆盖</li>
<li>除首参数外（<code>null</code>、<code>undefined</code>会报错），非对象会被转换为对象</li>
</ul>
</li>
<li><p><code>Object.keys</code></p>
<p>返回对象<strong>自身的</strong>、<strong>可遍历的</strong>属性的键名<strong>数组</strong></p>
</li>
<li><p><code>Object.fromEntries/Object.entries</code></p>
<p><code>Object.fromEntries</code>将一个键值对数组转换为一个对象，适合将<code>Map</code>转换为<code>Object</code></p>
<p><code>Object.entries</code>逆操作，用于将<code>Object</code>转换为键值对数组</p>
</li>
</ul>
<h2 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h2><ul>
<li><p><code>Array.of</code></p>
<p>弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">//[ , , ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//[3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">//[3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//[3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.copyWithin()</code></p>
<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.flat() &amp;&amp; Array.prototype.flatMap()</code></p>
<p><code>flat()</code>用于将数据降维，参数为降低的维数（默认为1）,如果不管有多少层维，都要转为一维数组，可使用<code>Infinity</code>关键字作为参数</p>
<p>如果原数组有空位<code>flat()</code>会跳过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 1, 2]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, [<span class="number">2</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 1, [2]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, [<span class="number">2</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 1, 2]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, [<span class="number">2</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 1, 2]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>相当于<code>Array.prorotype.Map</code> + <code>Array.prorotype.flat</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [1, 2, 2, 4, 3, 6]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p><strong>WHAT</strong></p>
<p>遍历器（<code>iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了<code>iterator</code>接口，就可以完成<strong>遍历</strong>操作</p>
<p><strong>WHY</strong></p>
<p>JavaScript原有的表示集合的数据结构主要是数组（Array）和对象（Object），ES6又添加了<code>Map</code>、<code>Set</code>。这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样需要一种统一的接口机制来处理不同的数据结构</p>
<p>主要作用</p>
<ul>
<li><p>为各种数据结构提供一个统一的、简便的访问接口</p>
</li>
<li><p>使得数据结构的成员能够按某种次序排列</p>
</li>
<li><p>为<code>for...of</code>所使用</p>
<p>适合遍历Array，既有<code>forEach</code>的简洁又有<code>for</code>的<code>break</code>、<code>return</code>、<code>continue</code></p>
</li>
</ul>
<p><strong>HOW</strong></p>
<p><code>iterator</code>的遍历过程</p>
<ol>
<li>创建一个指针对象，指向当前的数据结构的起始位置。也就是说遍历器对象本质上就是一个指针对象</li>
<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</li>
<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</li>
</ol>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象，其中<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示是否遍历结束</p>
<p>ES6规定，默认的<code>iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是可遍历的（<code>iterable</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    data: [<span class="string">'hello'</span>, <span class="string">'world'</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator](): &#123;</span><br><span class="line">    	<span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: self.data[index++]</span><br><span class="line">                    	done: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: <span class="literal">undefined</span>,</span><br><span class="line">                    done: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原生具备iterator接口的数据结构：<code>Map、Array、Set、String、TypedArray、arguments、NodeList对象</code></p>
<h2 id="let-VS-const"><a href="#let-VS-const" class="headerlink" title="let VS const"></a>let VS const</h2><p>在let和const之间，建议优先使用const，尤其是在全局环境。const优于let的几个原因：</p>
<ul>
<li>const可以提醒阅读程序的人，这个变量不应该改变</li>
<li>const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式计算</li>
<li>JavaScript编译器会对const进行优化</li>
<li>长远来看，JavaScript可能会有多线程的实现，这时let表示的变量只应出现在单线程运行的代码中，不是多线程共享的，这样有利于线程安全</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><p>ES6提供的一种异步编程解决方案</p>
<p>形式上，<code>generator</code>函数是一个状态机，封装了多个内部状态。执行<code>generator</code>函数会返回一个<strong>遍历器对象</strong>。</p>
<p>语法上，<code>generator</code>函数是一个普通函数。<code>function</code>关键字与函数名之间有一个<code>*</code>；函数体内部使用<code>yield</code>表达式定义不同的内部状态</p>
<p>与普通函数不同，generator函数被调用后并不执行，返回的是一个指向内部状态的指针对象，也就是<strong>遍历器对象</strong>。下一步，必须调用遍历器对象的<code>next</code>方法使得指针移向下一个状态。也就是说每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str1 = <span class="keyword">yield</span> <span class="string">"hello"</span></span><br><span class="line">  <span class="comment">// str1 = 222</span></span><br><span class="line">  <span class="keyword">const</span> str2 = <span class="keyword">yield</span> <span class="string">"world"</span></span><br><span class="line">  <span class="comment">// str2 = 333</span></span><br><span class="line">  <span class="keyword">return</span> str2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter = gen()</span><br><span class="line"><span class="built_in">console</span>.log(iter.next())</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="number">222</span>))</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="number">333</span>))</span><br></pre></td></tr></table></figure>

<p>第一次调用，<code>generator</code>函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>值就是当前<code>yield</code>表达式的值，done的值为<code>false</code></p>
<p>第二次调用，<code>generator</code>从上次yield表达式停下来的地方一直执行到下一个<code>yield</code>表达式 👆 ……</p>
<p>第三次调用，<code>generator</code>函数从上次<code>yield</code>表达式停下来的地方一直执行到<code>return</code>语句，next返回的<code>value</code>值就是<code>return</code>后面表达式的值，<code>done</code>为true（如果是<code>yield</code>则为<code>false</code>）</p>
<p><code>yield</code>表达式本身没有返回值（或者说总是返回undefined）。<code>next</code>方法可以带一个参数，该参数会被当作<strong>上一个</strong><code>yield</code>表达式的返回值</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/18/ES6重点-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/18/ES6重点-0/" class="post-title-link" itemprop="url">ES6重点-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-18 23:43:05" itemprop="dateCreated datePublished" datetime="2020-02-18T23:43:05+08:00">2020-02-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-29 23:07:33" itemprop="dateModified" datetime="2020-02-29T23:07:33+08:00">2020-02-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy</a></h2><p><code>Proxy</code>用于<strong>修改某些操作的默认行为</strong>，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。<code>Proxy</code>可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener">Reflect</a></h2><p>*<em>WHAT *</em>😳</p>
<p>ES6为了<strong>操作对象</strong>而提供的新的API</p>
<p><strong>WHY</strong>   🤔</p>
<ol>
<li>将<code>Object</code>对象的一些明显是语语言内部的方法（比如<code>Object.defineProperty</code>）放到<code>Reflect</code>对象上，现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></li>
<li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为</li>
<li><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为</li>
</ol>
<p><strong>HOW</strong>  😮</p>
<p><code>Reflect</code>对象一共有13个静态方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于函数定义了自己的 apply 方法</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(target, thisArg, args)</span><br><span class="line"><span class="comment">// 等同于new target(...args) 这提供了一种不使用 new 来调用构造函数的方法</span></span><br><span class="line"><span class="built_in">Reflect</span>.construct(target, args)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(target, name, receiver)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(target, name, value, receiver)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(target, name, desc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(target, name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.has(target, name)</span><br><span class="line"><span class="comment">// 基本等同于Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.prevenExtensions(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(target, name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(target, prototype)</span><br></pre></td></tr></table></figure>

<p><code>Reflect</code> + <code>Proxy</code>实现观察者模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  observers.add(fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">      observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer())</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; person.name &#125;</span>, <span class="subst">$&#123; person.age &#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">observe(print)</span><br><span class="line">person.name = <span class="string">"tom1"</span></span><br></pre></td></tr></table></figure>

<p>📣 在观察者模式中，观察者是知道被观察者的，被观察者一一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过消息代理进行通信。在发布订阅模式中，组件时松散耦合的，正和观察者模式相反。观察者模式大多时候是同步的，比如当事件触发，被观察者就会调用观察者的方法；而发布订阅模式大多时候是异步的（使用消息队列）</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">Symbol</a></h2><p><strong>WHAT</strong> 😳</p>
<p><code>ES6</code>引入的一种新的原始数据类型，表示<strong>独一无二</strong>的值。它是<code>JavaScript</code>语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Object</code>、<code>Number</code></p>
<p>📣 不支持 <code>new Symbol()</code></p>
<p><strong>WHY</strong>   🤔</p>
<p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。Symbol值可作为对象属性名</p>
<p><strong>HOW</strong>   😮</p>
<p>Symbol值通过<code>Symbol</code>函数生成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameProperty = <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [nameProperty]: <span class="string">"a"</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(a))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = a[key];</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(a));</span><br></pre></td></tr></table></figure>

<p>API:</p>
<ul>
<li><p><code>Symbol.description</code></p>
<p>创建<code>Symbol</code>的时候，可以添加一个描述，但读取这个描述需要将<code>Symbol</code>显式转为字符串。<code>Symbol.description</code>可以方便的读取<code>Symbol</code>对应的描述</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameProp = <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line">nameProp.toString()</span><br><span class="line"><span class="built_in">console</span>.log(nameProp.description)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Symbol.for</code></p>
<p>重新使用同一个<code>Symbol</code>值。<code>Symbol.for</code>接受一个字符串作为参数，然后<strong>全局搜索</strong>有没有以该参数作为名称的Symbol值，若有，返回之；若没有，创建之</p>
<p><code>Symbol.for(&quot;name&quot;)</code>和<code>Symbol(&quot;name&quot;)</code>的区别：两者都会生成<code>Symbol</code>值；前者会被登记在<strong>全局</strong>环境中供搜索，后者不会</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">"name"</span>) === <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"name"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Symbol.keyFor</code></p>
<p>返回一个已<strong>登记</strong>的<code>Symbol</code>的<code>key</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(<span class="built_in">Symbol</span>(<span class="string">"name"</span>)));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(<span class="built_in">Symbol</span>.for(<span class="string">"name"</span>)));</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>WHAT</strong> 😳</p>
<p>ES6提供的一种数据结构，类似于数组，但成员的值都是唯一的，没有重复的值</p>
<p>Set使用一种类似于<code>===</code>的算法“Same-value-zero equality”来判断值是否相等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "5" 和 5 不相等</span></span><br><span class="line"><span class="comment">// NaN 和 NaN 相等</span></span><br><span class="line"><span class="comment">// 两个空对象不相等</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add("5")</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add(NaN)</span><br><span class="line"><span class="keyword">set</span>.add(NaN)</span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;)</span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>);</span><br><span class="line">// Set &#123; <span class="string">'5'</span>, <span class="number">5</span>, <span class="literal">NaN</span>, &#123;&#125;, &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>WHY</strong>   🤔</p>
<ul>
<li>可以用作数组去重<code>[...new Set([1, 1, 2, 2, 3])]</code></li>
<li>去除字符串里面的重复字符<code>[...new Set(&#39;aaabbbc&#39;)].join(&quot;&quot;)</code></li>
</ul>
<p><strong>HOW</strong>   😮</p>
<p><code>Set</code>函数可以接受一个数组（或<strong>具有interable接口</strong>的其他数据结构）作为参数，用来初始化</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><strong>WHAT</strong> 😳</p>
<p>ES6提供的一种数据结构，类似于对象，也是键-值对的集合，但键的范围不限于字符串，各章类型的值（包括对象）都可以作为键</p>
<p><strong>WHY</strong>   🤔</p>
<p>传统上的Object只能用字符串（[Symbol](## Symbol)）作为键，这给它的使用带来了很大的限制</p>
<p>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性和原作者的属性同名</p>
<p><strong>HOW</strong>   😮</p>
<p>使用 <code>new Map</code> 来创建Map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">2</span>, <span class="string">"2"</span>]])</span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">"1"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>事实上，不仅仅是数组，任何具有<code>iterator</code>接口、且每个成员都是一个双元素的数组的数据结构都可以作为<code>Map</code>构造函数的参数</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/17/JavaScript相关-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/17/JavaScript相关-4/" class="post-title-link" itemprop="url">JavaScript相关-4</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-17 22:25:05 / 修改时间：22:25:45" itemprop="dateCreated datePublished" datetime="2020-02-17T22:25:05+08:00">2020-02-17</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="模拟实现call、apply"><a href="#模拟实现call、apply" class="headerlink" title="模拟实现call、apply"></a>模拟实现call、apply</h2><p>实现思路：</p>
<ul>
<li>不传入第一个参数，那么默认为<code>window</code></li>
<li>改变了<code>this</code>指向，让新对象可以执行该函数，那个思路可以变成给新对象添加一个函数，然后在执行完成之后删除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">arguments</span>[<span class="number">1</span>] ? context.fn(...arguments[<span class="number">1</span>]) : context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"error"</span>)</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> that(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> that.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  say (tmp1, tmp2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, tmp1, tmp2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jack = &#123;</span><br><span class="line">  name: <span class="string">"jack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tom.say.myCall(jack, <span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line">tom.say.call(jack, <span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line"></span><br><span class="line">tom.say.myApply(jack, [<span class="string">"111"</span>, <span class="string">"222"</span>])</span><br><span class="line">tom.say.apply(jack, [<span class="string">"111"</span>, <span class="string">"222"</span>])</span><br><span class="line"></span><br><span class="line">tom.say.myBind(jack)(<span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line">tom.say.bind(jack)(<span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h2><p><code>Promise</code>是ES6新增的语法，解决了回调地狱的问题。可以把<code>Promise</code>看作是一个状态机，可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>或<code>rejected</code>，状态一旦转变就不能再次变化</p>
<p><code>then</code>函数会返回一个新的<code>Promise</code>实例。因为<code>Promise</code>规范规定除了<code>pending</code>状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个<code>then</code>调用就失去意义了</p>
<p>对于<code>then</code>，本质上可以把它看成是<code>flatMap</code></p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>proxy是ES6中新增的功能，用来定义对象中的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onwatch</span>(<span class="params">obj, setBind, getLogger</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, property, value) &#123;</span><br><span class="line">      setBind(target, property, value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p = onwatch(obj, (target, property, value) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`set <span class="subst">$&#123; property &#125;</span> = <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;, (target, property) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`get <span class="subst">$&#123; property &#125;</span> = <span class="subst">$&#123; target[property] &#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(p.a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set a = 2</span></span><br><span class="line"><span class="comment">// get a = 2</span></span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><strong>元字符</strong></p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">匹配任意字符除了换行、回车符</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">？之前字符可选</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="center">匹配方括号内任意字符</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">^9表示匹配以9开头</td>
</tr>
<tr>
<td align="center">{1, 2}</td>
<td align="center">匹配1到2位字符</td>
</tr>
<tr>
<td align="center">(abc)</td>
<td align="center">只匹配abc</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">匹配|前后任意字符</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">转义</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">只匹配0次及以上*前的字符</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">只匹配1次及以上*前的字符</td>
</tr>
</tbody></table>
<p><strong>修饰语</strong></p>
<table>
<thead>
<tr>
<th align="center">修饰语</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">忽略大小写</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">全局搜索</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">多行</td>
</tr>
</tbody></table>
<p><strong>字符简写</strong></p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\w</td>
<td align="center">匹配字母数字或下划线</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">和👆相反</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配任意的字符</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">匹配数字</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配单词的开始或结束</td>
</tr>
</tbody></table>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p><strong>WHAT</strong></p>
<p>不再用到的内存没有及时释放，就叫做内存泄漏。如果这种情况越来越多，会导致内存不够用而系统崩溃。很多编程语言需要手动释放内存，但也有一部分编程语言提供自动内存管理，这被称为垃圾回收机制。</p>
<p><strong>WHY</strong></p>
<p>避免出现内存泄漏</p>
<p><strong>HOW</strong></p>
<p>V8下的垃圾回收机制：</p>
<p>V8实现了准确式GC，GC算法采用了分代式垃圾回收机制，因此V8将内存（堆）分为<strong>新生代</strong>和<strong>老生代</strong>两部分</p>
<ul>
<li><p>新生代算法</p>
<p>新生代中的对象一般存活时间较短，使用 scavenge GC 算法</p>
<p>在新生代空间中，内存空间分为两部分，分别为<strong>from空间</strong>和<strong>to空间</strong>。在这两个空间中，必定有一个空间时使用的，另一个空间是空闲的。新分配的对象会被放入from空间中。当from空间被占满时，新生代GC就会启动了。算法会检查from空间中存活的对象并复制到to空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to空间互换，这样GC就结束了</p>
</li>
<li><p>老生代算法</p>
<p>老生代中的对象一般存活事件较常切数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法</p>
<p>以下情况对象会出现在老生代空间中</p>
<ul>
<li>新生代中的对象已经历过一次scavenge算法</li>
<li>to空间中的对象占比大小超过25%，在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中</li>
</ul>
<p>在老生代中，以下情况会启动标记清楚算法</p>
<ul>
<li>某一空间没有分块的时候</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型堆内存时，可能需要几百毫秒才能完成一次标记，这就会导致一些性能上的问题。为了解决这个问题，2011年V8从stop-the-world标记切换到增量标记</p>
<p>清楚对象后会造成堆内存出现碎片的情况，当碎片超过一定先之后会启动压缩算法，在压缩过程中将蝴蝶对象向一端移动，直到所有对象都移动完成后清理掉不需要的内存</p>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>经典继承（构造函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">colors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = colors</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">colors</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, colors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s.colors);</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>​    可以传递构造参数</p>
<p>缺点：</p>
<ul>
<li>继承的方法都在构造函数中定义，构造函数不能够复用了</li>
<li>父类中定义的方法对于子类而言是不可见的</li>
</ul>
</li>
<li><p>原型继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  friends: [<span class="string">"jack"</span>, <span class="string">"linda"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = object(person)</span><br><span class="line">p1.name = <span class="string">"p1"</span></span><br><span class="line">p1.friends.push(<span class="string">"bob"</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Object</span>.create(person)</span><br><span class="line">p2.name = <span class="string">"p2"</span></span><br><span class="line">p2.friends.push(<span class="string">"lili"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);</span><br></pre></td></tr></table></figure>

<p>在<code>object</code>函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个实例。从本质上讲，<code>object()</code>将传入其中的对象执行了一次<strong>浅复制</strong></p>
<p>原型继承适用于只想让一个对象与另一个对象保持类似的情况</p>
</li>
<li><p>组合继承 👍</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类属性，第一次调用Father() </span></span><br><span class="line">  Father.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类方法，第二次调用Father()</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Son(<span class="string">"tom"</span>, <span class="number">21</span>)</span><br><span class="line">s1.colors.push(<span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.colors)</span><br><span class="line">s1.sayAge()</span><br><span class="line">s1.sayName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Son(<span class="string">"jack"</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s2.colors)</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生式继承</p>
<p>寄生式继承是与原型链继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// object(): 任何能返回新对象的函数</span></span><br><span class="line">    <span class="keyword">const</span> clone = object(original)</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        conosle.log(<span class="string">"hi"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生组合式继承 👍👍</p>
<p>组合继承的最大问题在于无论什么情况下都会调用两次父类型构造函数</p>
<p>寄生组合式继承即<strong>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="built_in">Object</span>.create(superType.prototype)</span><br><span class="line">  prototype.constructor = subType</span><br><span class="line">  subType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> SubType(<span class="string">"sub1"</span>, <span class="number">21</span>)</span><br><span class="line">sub1.sayAge()</span><br><span class="line">sub1.sayName()</span><br></pre></td></tr></table></figure>

</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/14/JavaScript相关-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/14/JavaScript相关-3/" class="post-title-link" itemprop="url">JavaScript相关-3</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-14 23:22:46 / 修改时间：23:23:32" itemprop="dateCreated datePublished" datetime="2020-02-14T23:22:46+08:00">2020-02-14</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>当执行JavaScript代码时，会产生三种执行上下文：</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code>执行上下文</li>
</ul>
<p>每个执行上下文中都有三种重要的属性：</p>
<ul>
<li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局执行上下文中访问（函数执行上下文中尉AO）</li>
<li>作用域链（Scope），JavaScript采用词法作用域，也就是说变量的作用域实在定义的时候就决定了，包含自身变量对象和上级变量对象的列表，通过<code>[[Scope]]</code>属性查找上级变量</li>
<li><code>this</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">globalContext.VO === global</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    foo: <span class="xml"><span class="tag">&lt;<span class="name">Function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">fooContext.AO === foo.AO</span></span><br><span class="line"><span class="xml">fooContext.AO = &#123;</span></span><br><span class="line"><span class="xml">    i: undefined,</span></span><br><span class="line"><span class="xml">    b: undefined,</span></span><br><span class="line"><span class="xml">    arguments: <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数独有的对象（箭头函数没有）</span></span><br><span class="line"><span class="xml">// 该对象时一个伪数组</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">fooContext.[[Scope]] = &#123;</span></span><br><span class="line"><span class="xml">    globalContext.VO</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">fooContext.Scope = fooContext.[[Scope]] + fooContext.VO</span></span><br><span class="line"><span class="xml">fooContext.Scope = [</span></span><br><span class="line"><span class="xml">    fooContext.VO,</span></span><br><span class="line"><span class="xml">    globalContext.VO</span></span><br><span class="line"><span class="xml">]</span></span><br></pre></td></tr></table></figure>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>通俗解释：</p>
<p>将声明的代码移动到了顶部</p>
<p>准确解释：👍</p>
<p>在生成执行上下文时，会有两个阶段</p>
<ol>
<li>创建的阶段（具体步骤是创建VO），JavaScript解释器会找出需要提升的变量和函数，并且给它们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量之生命并且赋值为<code>undefined</code></li>
<li>代码执行阶段（可以直接使用变量/函数）</li>
</ol>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>在一定时间多次触发但内只调用一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait = <span class="number">50</span>, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, context, args;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, params)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="keyword">this</span></span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/12/JavaScript相关-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/12/JavaScript相关-2/" class="post-title-link" itemprop="url">JavaScript相关-2</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-12 22:53:13" itemprop="dateCreated datePublished" datetime="2020-02-12T22:53:13+08:00">2020-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-18 10:44:40" itemprop="dateModified" datetime="2020-02-18T10:44:40+08:00">2020-02-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><strong>WHAT</strong></p>
<p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.</p>
<p>异步编程的一种解决方案</p>
<p><code>Promise</code>可能处于以下三个状态之一：<code>fulfilled</code>、<code>rejected</code>、<code>pending</code>。用户可以对<code>Promise</code>添加回调函数来处理操作成功的结果或失败的原因</p>
<p><strong>WHY</strong></p>
<p>传统的异步编程缺点难以忍受:</p>
<ul>
<li>代码臃肿</li>
<li>可读性差</li>
<li>耦合度过高，可维护性差</li>
<li>代码复用性差</li>
<li>只能在回调里处理异常</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">请求<span class="number">1</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    请求<span class="number">2</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">        请求<span class="number">3</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">3</span></span>)</span>&#123;</span><br><span class="line">            请求<span class="number">4</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">                请求<span class="number">5</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">5</span></span>)</span>&#123;</span><br><span class="line">                    请求<span class="number">6</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">6</span></span>)</span>&#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(请求<span class="number">1</span>)</span><br><span class="line">    .then(请求<span class="number">2</span>(请求结果<span class="number">1</span>))</span><br><span class="line">    .then(请求<span class="number">3</span>(请求结果<span class="number">2</span>))</span><br><span class="line">    .then(请求<span class="number">4</span>(请求结果<span class="number">3</span>))</span><br><span class="line">    .then(请求<span class="number">5</span>(请求结果<span class="number">4</span>))</span><br><span class="line">    .catch(处理异常(异常信息))</span><br></pre></td></tr></table></figure>

<p><strong>HOW</strong></p>
<p>常用API：</p>
<ul>
<li><p><code>Promise.resolve(value)</code></p>
<p>返回一个状态由给定的<code>value</code>决定的<code>Promise</code>对象。如果该值时<code>theable</code>（即带有then方法的对象），返回的<code>Promise</code>对象的最终状态是由<code>then</code>方法决定；否则（该<code>value</code>为空、基本类型或不带<code>then</code>方法的对象）返回的<code>Promise</code>对象状态为<code>fulfilled</code>，并且将该<code>value</code>传递给对应的<code>then</code>方法。通常，如果不知道一个值是否是<code>Promise</code>对象，可以使用<code>Promsie.resolve(value)</code>来返回一个<code>Promise</code>对象，这样就能将该<code>value</code>以<code>Promise</code>对象形式使用</p>
</li>
<li><p><code>Promise.reject(value)</code></p>
<p>返回一个状态为失败的<code>Promise</code>对象，并将给定的失败信息传递给对应的出处理方法</p>
</li>
<li><p><code>Promise.race(interable)</code></p>
<p>当<code>interable</code>参数里的任意一个子<code>promise</code>被执行失败或成功后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promsie</code>绑定的相应句柄并返回该<code>promsie</code>对象</p>
</li>
<li><p><code>Promise.all(interable)</code></p>
<p>这个方法返回的是一个新的<code>promise</code>对象，该<code>promise</code>对象在<code>interable</code>参数对象里所有的<code>promise</code>对象都成功的时候才会触发成功，一旦有任何一个<code>interable</code>里的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>interable</code>里所有<code>promise</code>返回值的数组作为成功回调的返回值，顺序跟<code>interable</code>的顺序保持一致；如果这个新的<code>promise</code>对象出发了失败状态，它会把<code>interable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。<code>Promise.all</code>方法常用于处理多个<code>promise</code>对象的状态集合</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">"./index.html"</span>, &#123; <span class="attr">encoding</span>: <span class="string">"utf8"</span> &#125;, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err, data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_readFile</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">"./index.html"</span>, options, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(err)</span><br><span class="line">        reject(err)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> _readFile(<span class="string">"./index.html"</span>, <span class="string">"utf8"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="遍历对象的属性和数组元素的方法"><a href="#遍历对象的属性和数组元素的方法" class="headerlink" title="遍历对象的属性和数组元素的方法"></a>遍历对象的属性和数组元素的方法</h2><p>对象：</p>
<ul>
<li><p><code>for</code>循环 👎</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> obj)</span><br><span class="line">    <span class="built_in">console</span>.log(property)</span><br></pre></td></tr></table></figure>

<p>缺点：会遍历到它的继承属性，在使用之前需要加入<code>obj.hasOwnProperty(property)</code></p>
</li>
<li><p><code>Object.keys(obj).forEach()</code> 👍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">property</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(property)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Object.keys</code>返回一个有给定对象的自身可枚举属性组成的数组</p>
</li>
<li><p><code>Object.getOwnPropertyNames(obj).forEach</code> 👍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="function"><span class="params">property</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(property)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyNames</code>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括<code>Symbol</code>值作为名称的属性）组成的数组</p>
</li>
<li><p><code>Reflect.ownKeys(target)</code> 👍</p>
<p>基本等同于<code>Object.getOwnPeopertyNames</code> + <code>Object.getOwnPropertySymbols</code></p>
</li>
</ul>
<p>数组：<strong>各取所需</strong></p>
<ul>
<li><p><code>for</code>循环</p>
<p>普通遍历方法，较常用</p>
</li>
<li><p><code>arr.forEach</code></p>
<p>相较于<code>for</code>，<code>forEach</code>不可提前结束循环</p>
</li>
<li><p><code>arr.map/reduce</code></p>
</li>
</ul>
<h2 id="可变对象和不可变对象"><a href="#可变对象和不可变对象" class="headerlink" title="可变对象和不可变对象"></a>可变对象和不可变对象</h2><p><strong>可变对象</strong>在创建之后是可以被改变的</p>
<p><strong>不可变对象</strong>在创建之后是不可以被改变的</p>
<ol>
<li>在<code>JavaScript</code>中，<code>string</code>和<code>number</code>从设计之初就是不可变的（immediate）</li>
<li>不可变对象是保持一个对象状态不变，这样的好处是是的开发更加简单、可回溯、测试友好，减少了任何可能的副作用。但是，每当想添加点东西到一个不可变对象里时，它一定是先拷贝已存在的值到新实例里，然后再给新实例添加内容，最后返回新实例。相比可变对象，这势必会有更多内存、计算量消耗</li>
</ol>
<p>创建一个纯函数（pure function）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    school: <span class="string">"baidu"</span>,</span><br><span class="line">    name: <span class="string">"tom"</span>,</span><br><span class="line">    age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateStudent</span>(<span class="params">student, name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...student,</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步函数和异步函数"><a href="#同步函数和异步函数" class="headerlink" title="同步函数和异步函数"></a>同步函数和异步函数</h2><p>同步函数阻塞，异步函数不阻塞。在同步函数中，语句完成后下一句才执行，在这种情况下，程序可以按照语句的顺序进行精确评估，如果其中一个语句需要很长时间，那么程序的执行会停滞很长时间</p>
<p>异步函数通常接受回调作为参数，在调用异步函数后立即继续执行下一行。回调函数仅在异步操作完成且调用堆栈为空时调用，诸如从web服务器加载数据或查询数据库等重负载操作应该异步完成，以便主线程可以继续执行其他操作而不会出现一直阻塞</p>
<p>在JavaScript中异步函数的解决方案通常有callback、Promise、async/await</p>
<h2 id="JavaScript执行机制"><a href="#JavaScript执行机制" class="headerlink" title="JavaScript执行机制"></a>JavaScript执行机制</h2><ul>
<li><p><strong>JavaScript的执行与运行</strong></p>
<p>执行和与运行不太相同，在不同环境下，比如Node、浏览器下，JavaScript的执行结果是不一样的；而运行大多是指基于JavaScript引擎，如V8，结果是一致的 </p>
</li>
<li><p><strong>关于JavaScript</strong></p>
<p>众所周知，JavaScript是一门<strong>单线程</strong>、<strong>异步执行</strong>的语言，虽然在HTML5中提出了<strong>web workers</strong>（可以理解为<strong>浏览器</strong>为JavaScript开的“外挂”），但JavaScript是单线程运行的这一核心仍未改变，所有多线程都是通过单线程<strong>模拟</strong>出来的</p>
</li>
<li><p><strong>JavaScript中的异步</strong> <strong>event-loop</strong></p>
<p>JavaScript中的异步主要通过<strong>event loop</strong>进行模拟当我们执行JavaScript代码的时候其实就是往执行栈中放入函数，那么遇到异步代码怎么办？其实当遇到异步代码时，会被挂起并在需要执行的时候加入到<strong>Task</strong>（有多种Task）队列中。一旦执行栈为空，<strong>event loop</strong>就会从<strong>Task</strong>中拿出需要执行的代码并放入执行栈中执行，所以本质上说JavaScript中的异步还是同步行为</p>
</li>
<li><p><strong>浏览器中的event loop</strong></p>
<p>来自不同的<strong>任务源</strong>的任务会被分配到不同的Task队列中，任务源可以分为<strong>微任务（micro task）</strong>和<strong>宏任务（macro task）</strong>。在ES6规范中，微任务被称为jobs，宏任务被称为task</p>
<p>微任务包括：<code>precess.nextTick</code>、<code>promise</code>、<code>Mutation Observer</code></p>
<p>宏任务包括：<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>I/O</code>、UI Rendering</p>
<p><strong>宏任务中包含了<code>script</code>，因此浏览器会先执行一个宏任务，接下来由异步代码的话才会先执行微任务</strong></p>
<p><strong>event loop执行顺序</strong>：</p>
<ol>
<li>先执行同步代码，这属于宏任务</li>
<li>当<strong>执行完所有同步代码</strong>后执行栈为空，查询是否有异步代码需要执行</li>
<li><strong>执行所有微任务</strong></li>
<li>当执行完所有微任务，如有必要会渲染页面</li>
<li>然后开始下一轮<code>event loop</code>，执行宏任务中的异步代码也就是<code>setTimeout</code>（宏任务）中的回调函数</li>
</ol>
<p><img src="./imgs/browser_event_loop.png" alt="浏览器中的event loop"></p>
<p><img src="./imgs/browser_event_loop2.png" alt="浏览器中的event loop"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  resolve(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 4 7 5 2 3 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Node.js中的event loop</strong></p>
<p>Node.js中的<code>event loop</code>分为6个阶段，他们会按照顺序反复运行。每当进入某一个阶段的时候都会从对应的回调队列中取出函数去执行。当<strong>队列为空</strong>或者<strong>执行的回调函数数量到达系统设定的阈值</strong>，就会进入下一阶段</p>
<p><img src="./imgs/node_event_loop.png" alt="Node.js中的event loop"></p>
<ol>
<li><p><strong>timers</strong></p>
<p><strong>timers</strong>阶段会执行<code>setTimeout</code>和<code>setinterval</code>回调，并且是由<strong>poll</strong>阶段控制的。同样在<code>Node.js</code>中定时器指定的事件也不是准确时间，只是尽快执行</p>
</li>
<li><p><strong>I/O</strong></p>
<p><strong>I/O</strong>阶段会处理一些上一轮循环中少许未执行的<strong>I/O</strong>回调</p>
</li>
<li><p><strong>idle,prepare</strong></p>
</li>
<li><p><strong>poll</strong></p>
<p><strong>poll</strong>是一个至关重要的阶段，在这一阶段中，系统会做两件事情</p>
<ol>
<li><p>回到<strong>timer</strong>阶段执行回调</p>
</li>
<li><p>执行<strong>I/O</strong>回调，并且在进入该阶段时如果没有设定了<strong>timer</strong>的话，会发生以下两件事情</p>
</li>
</ol>
<ul>
<li>如果<strong>poll</strong>队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果<strong>poll</strong>队列为空<ul>
<li>如果有<code>setImmediate</code>回调需要执行，<strong>poll</strong>阶段会停止并且<strong>进入到check阶段</strong>执行回调</li>
<li>如果没有，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间防止一直等待下去</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>check</strong></p>
<p>执行<code>setImmediate</code></p>
</li>
<li><p><strong>close callbacks</strong></p>
<p>执行close事件</p>
</li>
</ol>
<p><img src="./imgs/node_event_loop2.png" alt="Node.js中的event loop"></p>
</li>
</ul>
<h2 id="ES6的类和ES6的构造函数的区别"><a href="#ES6的类和ES6的构造函数的区别" class="headerlink" title="ES6的类和ES6的构造函数的区别"></a>ES6的类和ES6的构造函数的区别</h2><p>在普通使用中没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要区别在于类继承上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype)</span><br><span class="line">Student.prototype.constructor = Student</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    consreuctor(name, id) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符和剩余参数语句的区别"><a href="#扩展运算符和剩余参数语句的区别" class="headerlink" title="扩展运算符和剩余参数语句的区别"></a>扩展运算符和剩余参数语句的区别</h2><p>在函数泛型编码时，ES6的扩展运算符非常有用吗，因为我们可以轻松创建数组和对象的拷贝，而无需使用<code>Object.create</code>、<code>slice</code>或其他函数库。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [ ...arr, <span class="string">"test"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = test([<span class="string">"hello"</span>, <span class="string">"world"</span>])</span><br><span class="line"><span class="comment">// ["hello", "world", "test"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"tom"</span>,</span><br><span class="line">    age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copyPerson = &#123; ...person &#125;</span><br></pre></td></tr></table></figure>

<p>ES6的剩余参数语句提供了一个简写，允许我们将不定数量的参数表示为一个<strong>数组</strong>，它就像扩展运算符语法的反面，将数据收集到数组中而不是解构数组。剩余参数语句在函数参数、数组和对象的解构赋值中有很大作用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [6, 7, 8, 9]</span></span><br><span class="line"><span class="keyword">const</span> result2 = test(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="comment">// [10, 11, 12, 13, 14]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ a, b, ...rest ] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">// 1 2 [ 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>JavaScript中分为<strong>七种</strong>内置类型，其中内置类型又分为两大类型：<strong>基本类型</strong>和<strong>引用类型</strong>（对象 Object）</p>
<p>基本类型：<code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></p>
<p>其中JavaScript的数字类型是浮点类型的，没有整形。并且浮点类型基于 IEEE 754 标准实现，在使用中会遇到某些 <a href="#2">Bug </a><code>NaN</code>也属于<code>number</code>类型并且<code>NaN</code>并不等于自身</p>
<p>对于基本类型来说，如果使用字面量的方式，那个这个变量只是个字面量，只有在必要的时候才会转换成对应的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">111</span> <span class="comment">// 这只是字面量，不是number类型</span></span><br><span class="line">a.toString() <span class="comment">// 使用的时候才会转换为对象类型</span></span><br></pre></td></tr></table></figure>

<p>引用类型在使用过程中会遇到深拷贝和浅拷贝问题</p>
<h2 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h2><p><code>typeof</code>对于基本类型，除了<code>null</code>都可以显示正确的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code>对于对象，除了函数都会显示<code>object</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>关于为什么<code>typeof null == object</code>：在JavaScript的最初版本中，使用的是32为系统，为了性能考虑使用低位存储了变量的类型信息。<code>000</code>开头的代表是对象，然而<code>null</code>表示为全零，所以将它错误的判断为<code>object</code></p>
<p>如果想得到一个正确的数据类型，使用<code>Object.prototype.toString.call(xxx)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instance</code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能正确的找到类型的<code>prototype</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    left = left.__proto__</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (prototypr === left)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>在调用<code>new</code>的过程中会发生以下四件事情</p>
<ol>
<li>新生成了一个对象</li>
<li>绑定到原型</li>
<li>绑定<code>this</code></li>
<li>返回新对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/11/JavaScript相关-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/11/JavaScript相关-1/" class="post-title-link" itemprop="url">JavaScript相关-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-11 23:33:22" itemprop="dateCreated datePublished" datetime="2020-02-11T23:33:22+08:00">2020-02-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 23:16:12" itemprop="dateModified" datetime="2020-02-12T23:16:12+08:00">2020-02-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h2><p><code>document.write()</code> 方法将一个文本字符串写入一个由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/open" target="_blank" rel="noopener"><code>document.open()</code></a> 打开的文档流（document stream）。（<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/write" target="_blank" rel="noopener">MDN</a>）</p>
<p>作用：</p>
<p>加载只有启用JavaScript后的样式文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.open()</span></span><br><span class="line"><span class="xml">    docuemnt.write('<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style_neads_js.css"</span> /&gt;</span>')</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.close()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>弊端：</p>
<ul>
<li>在非loading阶段使用<code>docuemnt.write</code>会清除已加载的页面</li>
<li><code>docuemnt.write</code>不能够在XHTML中使用</li>
<li>嵌入script中的<code>docuemnt.write</code>不能给任意节点添加子节点，因为它是随着DOM的构建执行的</li>
<li>利用<code>docuemnt.write</code>写入HTML字符流并不是一个好方法，它有违DOM操作的概念</li>
<li>利用<code>docuemnt.write</code>添加script加载外部脚本时，浏览器的HTML解析会被script的加载所阻塞</li>
</ul>
<h2 id="功能检测（feature-detection）、功能推断（feature-inference）、和使用UA字符串之间有什么区别"><a href="#功能检测（feature-detection）、功能推断（feature-inference）、和使用UA字符串之间有什么区别" class="headerlink" title="功能检测（feature detection）、功能推断（feature inference）、和使用UA字符串之间有什么区别"></a>功能检测（feature detection）、功能推断（feature inference）、和使用UA字符串之间有什么区别</h2><p>功能检测（feature detection） 👍</p>
<p>功能检测包括确定浏览器是否支持某段代码，以及是否能运行不同的代码（取决于它是否执行），一边浏览器能始终正确运行代码功能，而不会在某些浏览器中出现崩溃和错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"geolocation"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="comment">// 可以使用 navigator.geolocation</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 navigator.geolocation 功能缺失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能推断（feature inference）👎</p>
<p>功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后还会使用其他功能，因为它假设其他功能也可用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementsByTagName) &#123;</span><br><span class="line">  element = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UA 👎</p>
<p>这是一个浏览器报告的字符串，它允许网络协议对等方（network protocol peers）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过<code>navigator.userAgent</code>访问。然而，这个字符串很可能存在欺骗性，例如，chrome会同时作为chrome和safari进行报告，因此，要检测safari，除了检查safari字符串，还要检查是否同时存在chrome字符串。</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p><strong>WHAT</strong></p>
<p>Ajax（asynchronous JavaScript and XML）是使用客户端上的许多web技术，创建异步web应用的一种<strong>技术结合体</strong>。借助Ajax，web应用可以<strong>异步</strong>（在后台）向服务器发送数据可从服务器检索数据而不会干扰现有页面的显示和行为。通过将<strong>数据交互层与表示层分离</strong>，Ajax允许网页和扩展web应用程序动态更改内容而<strong>不需重新加载整个页面</strong>，实际上，现在通常将XML替换为JSON，因为JavaScript对JSON有原生支持优势</p>
<p><strong>WHY</strong></p>
<p>优点：</p>
<ul>
<li>交互性更好，来自服务器的新内容可以动态更改，无需重新加载整个页面</li>
<li>减少与服务器的连接，因为脚本和样式只需要被请求一次</li>
<li>状态可以维护在一个页面上，JavaScript变量和DOM状态将的到保持，因为主容器页面未被重新加载</li>
<li>基本上包含大部分SPA的优点</li>
</ul>
<p>缺点</p>
<ul>
<li>动态网页很难收藏</li>
<li>如果JavaScript在浏览器中被禁用则不起作用</li>
<li>有些网络爬虫不执行JavaScript，也不会看到JavaScript加载的内容</li>
</ul>
<p><strong>HOW</strong></p>
<ul>
<li>使用<code>CSS</code>和<code>XHTML</code>来表示</li>
<li>使用<code>DOM</code>模型来交互和动态显示</li>
<li>使用<code>XMLHttpRequest</code>来和服务器进行异步通信</li>
<li>使用<code>JavaScript</code>来绑定和调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = &#123;&#125;;</span><br><span class="line">ajax.httpRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> versions = [</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.6.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.5.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.4.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.3.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.2.0"</span>,</span><br><span class="line">        <span class="string">"Microsoft.XmlHttp"</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> xhr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; versions.length; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ajax.send = <span class="function"><span class="keyword">function</span> (<span class="params">url, callback, method, data, async</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">async</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">async</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> httpRequest = ajax.httpRequest();</span><br><span class="line">    httpRequest.open(method, url, <span class="keyword">async</span>);</span><br><span class="line">    httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (httpRequest.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">            callback(httpRequest.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        httpRequest.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    httpRequest.send(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ajax.get = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> query = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    ajax.send(url + (query.length ? <span class="string">'?'</span> + query.join(<span class="string">'&amp;'</span>) : <span class="string">''</span>), callback, <span class="string">'GET'</span>, <span class="literal">null</span>, <span class="keyword">async</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ajax.post = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> query = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    ajax.send(url, callback, <span class="string">'POST'</span>, query.join(<span class="string">'&amp;'</span>), <span class="keyword">async</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><strong>WHAT</strong></p>
<p>带填充的json（p for padding），是一种通常用于绕过浏览器中的跨域选址的方法，因为Ajax不允许跨域请求。</p>
<p>原理：利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据。</p>
<p><strong>WHY</strong></p>
<p>解决跨域（只适用于GET请求）</p>
<p><strong>HOW</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsonp.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, cb &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">        <span class="built_in">window</span>[cb] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(script)</span><br><span class="line">        &#125;</span><br><span class="line">        params = &#123; ...params, cb &#125;</span><br><span class="line">        <span class="keyword">let</span> tmp = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params)</span><br><span class="line">            tmp.push(<span class="string">`<span class="subst">$&#123; key &#125;</span>=<span class="subst">$&#123; params[key] &#125;</span>`</span>)</span><br><span class="line">        script.src = <span class="string">`<span class="subst">$&#123; url &#125;</span>?<span class="subst">$&#123; tmp.join(<span class="string">"&amp;"</span>) &#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(&#123; </span><br><span class="line">    url: <span class="string">"http://localhost:3000/say"</span>,</span><br><span class="line">    params: &#123; <span class="attr">wd</span>: <span class="string">"hello jsonp"</span> &#125;,</span><br><span class="line">    cb: <span class="string">"show"</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">"/say"</span>, (res, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; wd, cb &#125; = req.query</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;cb&#125;</span>('i am fine, and you?')`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升（hoisting）用于解释代码中变量声明行为的术语。使用<code>var</code>关键字声明或初始化的变量会将声明语句“提升”到当前作用域的顶部。但是只有声明才会触发提升，赋值语句将保持原样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// ReferenceError: bar is not defined</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line">foo(); <span class="comment">// 'foo'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// [Function: foo]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// undefined</span></span><br><span class="line">bar(); <span class="comment">// Uncaught TypeError: bar is not a function</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// [Function: bar]</span></span><br></pre></td></tr></table></figure>

<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>当一个事件在DOM元素上触发时，如果有时间监听器，它尝试处理该事件，然后事件冒泡到其父级元素，并发生同样的事情，最后直至到达祖先元素。时间冒泡机制是实现事件委托（event delegation）的原理</p>
<h2 id="attribute和property"><a href="#attribute和property" class="headerlink" title="attribute和property"></a>attribute和property</h2><p>attribute是在HTML中定义的，而property实在DOM上定义的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input1"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"hello"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input1"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.getAttribute(<span class="string">"value"</span>)) <span class="comment">// hello</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.value) <span class="comment">// hello</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 当在文本框中输入 ‘world’ 后</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.getAttribute(<span class="string">"value"</span>)) <span class="comment">// hello</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.value) <span class="comment">// world</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="document的load事件和DOMContentLoaded事件之间的区别"><a href="#document的load事件和DOMContentLoaded事件之间的区别" class="headerlink" title="document的load事件和DOMContentLoaded事件之间的区别"></a>document的load事件和DOMContentLoaded事件之间的区别</h2><p>DOMContentLoaded：👍</p>
<p>当初始的HTML文档本完全加载和解析完成之后，DOMContentLoaded事件被触发而无需等待样式表、图像和子框架的完成加载</p>
<p>load：</p>
<p>window的load事件仅在DOM和所有相关资源全部完成加载后才会触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"DOMContentLoaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"window loaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOMContentLoaded</span></span><br><span class="line"><span class="comment">// window loaded</span></span><br></pre></td></tr></table></figure>

<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是由Netscape提出的一个著名的安全策略，浏览器出于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读取对方的资源。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源的定义:</a></p>
<p>如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的<strong>源</strong>。我们也可以把它称为“协议/主机/端口 tuple”，或简单地叫做“tuple”. (“tuple” ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元)</p>
<p>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>http://store.company.com/dir2/other.html</code></td>
<td>成功</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><code>http://store.company.com/dir/inner/another.html</code></td>
<td>成功</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><code>https://store.company.com/secure.html</code></td>
<td>失败</td>
<td>协议不同</td>
</tr>
<tr>
<td><code>http://store.company.com:81/dir/etc.html</code></td>
<td>失败</td>
<td>端口不同</td>
</tr>
<tr>
<td><code>http://news.company.com/dir/other.html</code></td>
<td>失败</td>
<td>域名不同</td>
</tr>
</tbody></table>
<h2 id="JavaScript严格模式"><a href="#JavaScript严格模式" class="headerlink" title="JavaScript严格模式"></a>JavaScript严格模式</h2><p><strong>WHAT</strong></p>
<p>ES5最早引入了“严格模式”（strict mode）的概念。可选择的一个限制JavaScript的变体的一种方式</p>
<p><strong>WHY</strong></p>
<p>优点：</p>
<ul>
<li>无法再意外创建全局变量</li>
<li>会引起静默失败（sliently fail， 即：不报错也没有任何效果）的操作抛出异常<ul>
<li>对变量调用<code>delete</code>操作符</li>
<li>为只读属性赋值</li>
<li>对不可配置（nonconfigurable）的属性使用<code>delete</code>操作符</li>
</ul>
</li>
<li>试图删除不可删除的属性时会抛出异常</li>
<li>要求函数的参数名唯一</li>
<li>某些保留字（<code>interface</code>、<code>implements</code>、<code>package</code>等）不能作为变量名</li>
<li>抑制<code>this</code><ul>
<li>全局作用域下，<code>this</code>的值为<code>undefined</code></li>
<li><code>.call()</code>、<code>.apply()</code>传递错误的<code>this</code>会报错（非严格模式下会转换为全部对象）</li>
</ul>
</li>
<li>捕获了一些常见的编码错误，并抛出异常</li>
</ul>
<p>缺点：</p>
<ul>
<li>确实许多开发人员已经习惯的功能</li>
<li>无法访问<code>function.caller</code>和<code>function.arguments</code></li>
<li>以不同严格模式编写的脚本合并后可能会导致问题</li>
</ul>
<p><strong>HOW</strong></p>
<p>在需要启用严格模式的<strong>代码</strong>顶部添加：<code>&quot;use strict;&quot;</code></p>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p><strong>WHAT</strong></p>
<p>single page application 单页面应用</p>
<p>现如今，web程序员将他们构建的产品成为web应用而不是网站。虽然这两个术语之间没有严格的区别，但网络应用往往具有高度的交互性和动态性，允许用户执行操作并接受他们的操作响应。在过去，浏览器从服务器接收HTML并渲染，当用户导航到其他URL时，需要整页刷新，服务器会为新页面发送新的HTML，这被称为服务端渲染</p>
<p>然而，在现代的SPA中，客户端渲染取而代之。浏览器从都武器加载<strong>初始页面</strong>，整个应用程序所所需的脚本（库、框架、应用代码）和样式表。当用户导航到其他页面时，<strong>不会触发页面刷新</strong>，该页面的URL通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">HTML5 History API</a>进行更新。浏览器通过Ajax请求向服务器检索所需的数据（通常采用json格式），然后SPA<strong>通过JavaScript来动态更新页面</strong>，这些JavaScript在初始页面已经下载。这种模式类似于原生移动应用的工作方式。</p>
<p><img src="./imgs/spa.png" alt="SPA"></p>
<p><strong>WHY</strong></p>
<p>好处：</p>
<ul>
<li>用户感知响应更快，用户切换页面时不会再看到因页面刷新而导致的白屏</li>
<li>对服务器进行的HTTP请求减少，因为对于没和页面的加载不必再次下载相同的资源</li>
<li>客户端和服务端之间的关注点分离，可以为不同平台（手机、智能手表）建立新的客户端而不需修改服务器代码。</li>
</ul>
<p>弊端：</p>
<ul>
<li>由于加载了多个页面需要的框架、应用代码和资源导致初始页面加载时间过长</li>
<li>服务器还需额外的工作将是所有路由请求配置到单个入口点，然后由客户端接管路由</li>
<li>SPA依赖于JavaScript来渲染页面，对SEO不友好</li>
</ul>
<p><strong>HOW</strong></p>
<ol>
<li>向服务器请求初始页面并渲染，同时请求整个应用所需的脚本、样式</li>
<li>监听用户操作：<ul>
<li>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">HTML5 History API</a>进行页面导航</li>
<li>通过Ajax向服务器请求数据并使用JavaScript动态渲染到页面上</li>
</ul>
</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/imgs/avatar.png"
      alt="Mr.RS">
  <p class="site-author-name" itemprop="name">Mr.RS</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.RS</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>
