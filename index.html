<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png?v=7.4.1">
  <link rel="mask-icon" href="/images/avatar.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Mr.RS">
<meta property="og:url" content="https://mrrs878.github.io/index.html">
<meta property="og:site_name" content="Mr.RS">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.RS">
  <link rel="canonical" href="https://mrrs878.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Mr.RS</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.RS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Read The Fucking Source Code!</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      
    
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/19/ES6重点-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/19/ES6重点-1/" class="post-title-link" itemprop="url">ES6重点-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-19 23:01:48" itemprop="dateCreated datePublished" datetime="2020-02-19T23:01:48+08:00">2020-02-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-21 23:12:12" itemprop="dateModified" datetime="2020-02-21T23:12:12+08:00">2020-02-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符串新增方法"><a href="#字符串新增方法" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h2><ul>
<li><p><code>padStart</code></p>
<p>用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>)); <span class="comment">//补全位数，有需要会重复或截取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padStart(<span class="number">4</span>)); <span class="comment">// 不传第二个参数默认使用空格补全</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padStart(<span class="number">2</span>)); <span class="comment">// 补全后的长度小于源字符串长度则不做任何改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// abax</span></span><br><span class="line"><span class="comment">// axxx</span></span><br><span class="line"><span class="comment">//    x</span></span><br><span class="line"><span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>padEnd</code></p>
<p>和<code>padStart</code>效果相反，从尾部开始补全</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'abc'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.padEnd(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padEnd(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'xxx'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// xabca</span></span><br><span class="line"><span class="comment">// x   </span></span><br><span class="line"><span class="comment">// xxx</span></span><br><span class="line"><span class="comment">// xxxa</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对象新增扩展"><a href="#对象新增扩展" class="headerlink" title="对象新增扩展"></a>对象新增扩展</h2><ul>
<li><p>链判断运算符</p>
<p>在ES5中，取对象属性时，往往需要判断以下该对象是否存在。如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = (store </span><br><span class="line">    &amp;&amp; store.state </span><br><span class="line">    &amp;&amp; store.state.user </span><br><span class="line">    &amp;&amp; store.state.user.name) || <span class="string">"tom"</span></span><br></pre></td></tr></table></figure>

<p>这种层层判断过于麻烦，因此ES2020引入链判断运算符<code>?.</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = store?.state?.user?.name</span><br></pre></td></tr></table></figure>

<p>如果左侧的对象为<code>null</code>或<code>undefined</code>则直接返回<code>undefined</code>，不再往下运算</p>
</li>
<li><p><code>null</code>判断运算符</p>
<p>独去对象属性时，如果某个属性的值时<code>null</code>或<code>undefined</code>，有时需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = user.name || <span class="string">"tom"</span></span><br><span class="line"><span class="keyword">const</span> age = user.age || <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>原意是属性值为<code>null</code>或<code>undefined</code>时默认值就生效，但当<code>user.name</code>为空串或<code>user.age</code>为0时默认值也会生效</p>
<p>为此ES2020引入新的<code>null</code>判断运算符<code>??</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = user.name ?? <span class="string">"tom"</span></span><br><span class="line"><span class="keyword">const</span> age = user.age ?? <span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h2><ul>
<li><p><code>Object.is</code></p>
<p>用来替代 <code>==</code>和<code>===</code></p>
<p><code>==</code> 会进行自动类型转换，<code>===</code> 在比较+0和-0时返回<code>true</code>，<code>NaN</code>不等于自身</p>
</li>
<li><p><code>Object.assign</code></p>
<p>用于对象合并</p>
<ul>
<li>只拷贝源对象的<strong>自身、可枚举属性（含Symbol）</strong></li>
<li>浅拷贝</li>
<li>同名属性会被覆盖</li>
<li>除首参数外（<code>null</code>、<code>undefined</code>会报错），非对象会被转换为对象</li>
</ul>
</li>
<li><p><code>Object.keys</code></p>
<p>返回对象<strong>自身的</strong>、<strong>可遍历的</strong>属性的键名<strong>数组</strong></p>
</li>
<li><p><code>Object.fromEntries/Object.entries</code></p>
<p><code>Object.fromEntries</code>将一个键值对数组转换为一个对象，适合将<code>Map</code>转换为<code>Object</code></p>
<p><code>Object.entries</code>逆操作，用于将<code>Object</code>转换为键值对数组</p>
</li>
</ul>
<h2 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h2><ul>
<li><p><code>Array.of</code></p>
<p>弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">//[ , , ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//[3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">//[3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//[3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.copyWithin()</code></p>
<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.flat() &amp;&amp; Array.prototype.flatMap()</code></p>
<p><code>flat()</code>用于将数据降维，参数为降低的维数（默认为1）,如果不管有多少层维，都要转为一维数组，可使用<code>Infinity</code>关键字作为参数</p>
<p>如果原数组有空位<code>flat()</code>会跳过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 1, 2]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, [<span class="number">2</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 1, [2]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, [<span class="number">2</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 1, 2]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, [<span class="number">2</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 1, 2]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>相当于<code>Array.prorotype.Map</code> + <code>Array.prorotype.flat</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [1, 2, 2, 4, 3, 6]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p><strong>WHAT</strong></p>
<p>遍历器（<code>iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构执法了部署<code>iterator</code>接口，就可以完成<strong>遍历</strong>操作</p>
<p><strong>WHY</strong></p>
<p>JavaScript原有的表示集合的数据结构主要是数组（Array）和对象（Object），ES6又添加了<code>Map</code>、<code>Set</code>。这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样需要一种统一的接口机制来处理不同的数据结构</p>
<p>主要作用</p>
<ul>
<li><p>为各种数据结构提供一个统一的、简便的访问接口</p>
</li>
<li><p>使得数据结构的成员能够按某种次序排列</p>
</li>
<li><p>为<code>for...of</code>所使用</p>
<p>适合遍历Array，既有<code>forEach</code>的简洁又有<code>for</code>的<code>break</code>、<code>return</code>、<code>continue</code></p>
</li>
</ul>
<p><strong>HOW</strong></p>
<p><code>iterator</code>的遍历过程</p>
<ol>
<li>创建一个指针对象，指向当前的数据结构的起始位置。也就是说遍历器对象本质上就是一个指针对象</li>
<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</li>
<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</li>
</ol>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象，其中<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示是否遍历结束</p>
<p>ES6规定，默认的<code>iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是可遍历的（<code>iterable</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    data: [<span class="string">'hello'</span>, <span class="string">'world'</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator](): &#123;</span><br><span class="line">    	<span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: self.data[index++]</span><br><span class="line">                    	done: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: <span class="literal">undefined</span>,</span><br><span class="line">                    done: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原生具备iterator接口的数据结构：<code>Map、Array、Set、String、TypedArray、arguments、NodeList对象</code></p>
<h2 id="let-VS-const"><a href="#let-VS-const" class="headerlink" title="let VS const"></a>let VS const</h2><p>在let和const之间，建议优先使用const，尤其是在全局环境。const优于let的几个原因：</p>
<ul>
<li>const可以提醒阅读程序的人，这个变量不应该改变</li>
<li>const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式计算</li>
<li>JavaScript编译器会对const进行优化</li>
<li>长远来看，JavaScript可能会有多线程的实现，这时let表示的变量只应出现在单线程运行的代码中，不是多线程共享的，这样有利于线程安全</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><p>ES6提供的一种异步编程解决方案</p>
<p>语法上，<code>generator</code>函数是一个状态机，封装了多个内部状态。执行<code>generator</code>函数会返回一个<strong>遍历器对象</strong>。</p>
<p>形式上，<code>generator</code>函数是一个普通函数。<code>function</code>关键字与函数名之间有一个<code>*</code>；函数体内部使用<code>yield</code>表达式定义不同的内部状态</p>
<p>与普通函数不同，generator函数被调用后并不执行，返回的是一个只想内部状态的指针对象，也就是<strong>遍历器对象</strong>。下一步，必须调用遍历器对象的<code>next</code>方法使得指针一项下一个状态。也就是说每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，值到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str1 = <span class="keyword">yield</span> <span class="string">"hello"</span></span><br><span class="line">  <span class="comment">// str1 = 222</span></span><br><span class="line">  <span class="keyword">const</span> str2 = <span class="keyword">yield</span> <span class="string">"world"</span></span><br><span class="line">  <span class="comment">// str2 = 333</span></span><br><span class="line">  <span class="keyword">return</span> str2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iter = gen()</span><br><span class="line"><span class="built_in">console</span>.log(iter.next())</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="number">222</span>))</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="number">333</span>))</span><br></pre></td></tr></table></figure>

<p>第一次调用，<code>generator</code>函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>值就是当前<code>yield</code>表达式的值，done的值为<code>false</code></p>
<p>第二次调用，<code>generator</code>从上次yield表达式停下来的地方一直执行到下一个<code>yield</code>表达式 👆 ……</p>
<p>第三次调用，<code>generator</code>函数从上次<code>yield</code>表达式停下来的地方一直执行到<code>return</code>语句，next返回的<code>value</code>值就是<code>return</code>后面表达式的值，<code>done</code>为true（如果是<code>yield</code>则为<code>false</code>）</p>
<p><code>yield</code>表达式本身没有返回值（或者说总是返回undefined）。<code>next</code>方法可以带一个参数，该参数会被当作<strong>上一个</strong><code>yield</code>表达式的返回值</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/18/ES6重点-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/18/ES6重点-0/" class="post-title-link" itemprop="url">ES6重点-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-18 23:43:05 / 修改时间：23:44:05" itemprop="dateCreated datePublished" datetime="2020-02-18T23:43:05+08:00">2020-02-18</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy</a></h2><p><code>Proxy</code>用于<strong>修改某些操作的默认行为</strong>，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。<code>Proxy</code>可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener">Reflect</a></h2><p>*<em>WHAT *</em>😳</p>
<p>ES6为了<strong>操作对象</strong>而提供的新的API</p>
<p><strong>WHY</strong>   🤔</p>
<ol>
<li>将<code>Object</code>对象的一些明显是语语言内部的方法（比如<code>Object.defineProperty</code>）放到<code>Reflect</code>对象上，现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></li>
<li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为</li>
<li><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为</li>
</ol>
<p><strong>HOW</strong>  😮</p>
<p><code>Reflect</code>对象一共有13个静态方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于函数定义了自己的 apply 方法</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(target, thisArg, args)</span><br><span class="line"><span class="comment">// 等同于new target(...args) 这提供了一种不使用 new 来调用构造函数的方法</span></span><br><span class="line"><span class="built_in">Reflect</span>.construct(target, args)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(target, name, receiver)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(target, name, value, receiver)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(target, name, desc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(target, name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.has(target, name)</span><br><span class="line"><span class="comment">// 基本等同于Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.prevenExtensions(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(target, name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(target, prototype)</span><br></pre></td></tr></table></figure>

<p><code>Reflect</code> + <code>Proxy</code>实现观察者模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  observers.add(fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">      observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer())</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; person.name &#125;</span>, <span class="subst">$&#123; person.age &#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">observe(print)</span><br><span class="line">person.name = <span class="string">"tom1"</span></span><br></pre></td></tr></table></figure>

<p>🤔 在观察者模式中，观察者是知道被观察者的，被观察者一一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过消息代理进行通信。在发布订阅模式中，组件时松散耦合的，正和观察者模式相反。观察者模式大多时候是同步的，比如当事件触发，被观察者就会调用观察者的方法；而发布订阅模式大多时候是异步的（使用消息队列）</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">Symbol</a></h2><p><strong>WHAT</strong> 😳</p>
<p><code>ES6</code>引入的一种新的原始数据类型，表示<strong>独一无二</strong>的值。它是<code>JavaScript</code>语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Object</code>、<code>Number</code></p>
<p>📣 不支持 <code>new Symbol()</code></p>
<p><strong>WHY</strong>   🤔</p>
<p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。Symbol值可作为对象属性名</p>
<p><strong>HOW</strong>   😮</p>
<p>Symbol值通过<code>Symbol</code>函数生成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameProperty = <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [nameProperty]: <span class="string">"a"</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(a))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = a[key];</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(a));</span><br></pre></td></tr></table></figure>

<p>API:</p>
<ul>
<li><p><code>Symbol.description</code></p>
<p>创建<code>Symbol</code>的时候，可以添加一个描述，但读取这个描述需要将<code>Symbol</code>显式转为字符串。<code>Symbol.description</code>可以方便的读取<code>Symbol</code>对应的描述</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameProp = <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line">nameProp.toString()</span><br><span class="line"><span class="built_in">console</span>.log(nameProp.description)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Symbol.for</code></p>
<p>重新使用同一个<code>Symbol</code>值。<code>Symbol.for</code>接受一个字符串作为参数，然后<strong>全局搜索</strong>有没有以该参数作为名称的Symbol值，若有，返回之；若没有，创建之</p>
<p><code>Symbol.for(&quot;name&quot;)</code>和<code>Symbol(&quot;name&quot;)</code>的区别：两者都会生成<code>Symbol</code>值；前者会被登记在<strong>全局</strong>环境中供搜索，后者不会</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">"name"</span>) === <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"name"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Symbol.keyFor</code></p>
<p>返回一个已<strong>登记</strong>的<code>Symbol</code>的<code>key</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Symbol.keyFor(Symbol(&quot;name&quot;)));</span><br><span class="line">console.log(Symbol.keyFor(Symbol.for(&quot;name&quot;)));</span><br><span class="line">// undefined</span><br><span class="line">// name</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>WHAT</strong> 😳</p>
<p>ES6提供的一种数据结构，类似于数组，但成员的值都是唯一的，没有重复的值</p>
<p>Set使用一种类似于<code>===</code>的算法“Same-value-zero equality”来判断值是否相等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "5" 和 5 不相等</span></span><br><span class="line"><span class="comment">// NaN 和 NaN 相等</span></span><br><span class="line"><span class="comment">// 两个空对象不相等</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add("5")</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add(NaN)</span><br><span class="line"><span class="keyword">set</span>.add(NaN)</span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;)</span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>);</span><br><span class="line">// Set &#123; <span class="string">'5'</span>, <span class="number">5</span>, <span class="literal">NaN</span>, &#123;&#125;, &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>WHY</strong>   🤔</p>
<ul>
<li>可以用作数组去重<code>[...new Set([1, 1, 2, 2, 3])]</code></li>
<li>去除字符串里面的重复字符<code>[...new Set(&#39;aaabbbc&#39;)].join(&quot;&quot;)</code></li>
</ul>
<p><strong>HOW</strong>   😮</p>
<p><code>Set</code>函数可以接受一个数组（或<strong>具有interable接口</strong>的其他数据结构）作为参数，用来初始化</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><strong>WHAT</strong> 😳</p>
<p>ES6提供的一种数据结构，类似于对象，也是键-值对的集合，但键的范围不限于字符串，各章类型的值（包括对象）都可以作为键</p>
<p><strong>WHY</strong>   🤔</p>
<p>传统上的Object只能用字符串（[Symbol](## Symbol)）作为键，这给它的使用带来了很大的限制</p>
<p>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性和原作者的属性同名</p>
<p><strong>HOW</strong>   😮</p>
<p>使用 <code>new Map</code> 来创建Map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">2</span>, <span class="string">"2"</span>]])</span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">"1"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>事实上，不仅仅是数组，任何具有<code>iterator</code>接口、且没个成员都是一个双元素的数组的数据结构都可以作为<code>Map</code>构造函数的参数</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/17/JavaScript相关-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/17/JavaScript相关-4/" class="post-title-link" itemprop="url">JavaScript相关-4</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-17 22:25:05 / 修改时间：22:25:45" itemprop="dateCreated datePublished" datetime="2020-02-17T22:25:05+08:00">2020-02-17</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="模拟实现call、apply"><a href="#模拟实现call、apply" class="headerlink" title="模拟实现call、apply"></a>模拟实现call、apply</h2><p>实现思路：</p>
<ul>
<li>不传入第一个参数，那么默认为<code>window</code></li>
<li>改变了<code>this</code>指向，让新对象可以执行该函数，那个思路可以变成给新对象添加一个函数，然后在执行完成之后删除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">arguments</span>[<span class="number">1</span>] ? context.fn(...arguments[<span class="number">1</span>]) : context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"error"</span>)</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> that(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> that.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  say (tmp1, tmp2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, tmp1, tmp2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jack = &#123;</span><br><span class="line">  name: <span class="string">"jack"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tom.say.myCall(jack, <span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line">tom.say.call(jack, <span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line"></span><br><span class="line">tom.say.myApply(jack, [<span class="string">"111"</span>, <span class="string">"222"</span>])</span><br><span class="line">tom.say.apply(jack, [<span class="string">"111"</span>, <span class="string">"222"</span>])</span><br><span class="line"></span><br><span class="line">tom.say.myBind(jack)(<span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line">tom.say.bind(jack)(<span class="string">"111"</span>, <span class="string">"222"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br><span class="line"><span class="comment">// jack 111 222</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h2><p><code>Promise</code>是ES6新增的语法，解决了回调地狱的问题。可以把<code>Promise</code>看作是一个状态机，可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>或<code>rejected</code>，状态一旦转变就不能再次变化</p>
<p><code>then</code>函数会返回一个新的<code>Promise</code>实例。因为<code>Promise</code>规范规定除了<code>pending</code>状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个<code>then</code>调用就失去意义了</p>
<p>对于<code>then</code>，本质上可以把它看成是<code>flatMap</code></p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>proxy是ES6中新增的功能，用来定义对象中的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onwatch</span>(<span class="params">obj, setBind, getLogger</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, property, value) &#123;</span><br><span class="line">      setBind(target, property, value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p = onwatch(obj, (target, property, value) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`set <span class="subst">$&#123; property &#125;</span> = <span class="subst">$&#123; value &#125;</span>`</span>);</span><br><span class="line">&#125;, (target, property) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`get <span class="subst">$&#123; property &#125;</span> = <span class="subst">$&#123; target[property] &#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(p.a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set a = 2</span></span><br><span class="line"><span class="comment">// get a = 2</span></span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><strong>元字符</strong></p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">匹配任意字符除了换行、回车符</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">？之前字符可选</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="center">匹配方括号内任意字符</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">^9表示匹配以9开头</td>
</tr>
<tr>
<td align="center">{1, 2}</td>
<td align="center">匹配1到2位字符</td>
</tr>
<tr>
<td align="center">(abc)</td>
<td align="center">只匹配abc</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">匹配|前后任意字符</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">转义</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">只匹配0次及以上*前的字符</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">只匹配1次及以上*前的字符</td>
</tr>
</tbody></table>
<p><strong>修饰语</strong></p>
<table>
<thead>
<tr>
<th align="center">修饰语</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">忽略大小写</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">全局搜索</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">多行</td>
</tr>
</tbody></table>
<p><strong>字符简写</strong></p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\w</td>
<td align="center">匹配字母数字或下划线</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">和👆相反</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配任意的字符</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">匹配数字</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配单词的开始或结束</td>
</tr>
</tbody></table>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p><strong>WHAT</strong></p>
<p>不再用到的内存没有及时释放，就叫做内存泄漏。如果这种情况越来越多，会导致内存不够用而系统崩溃。很多编程语言需要手动释放内存，但也有一部分编程语言提供自动内存管理，这被称为垃圾回收机制。</p>
<p><strong>WHY</strong></p>
<p>避免出现内存泄漏</p>
<p><strong>HOW</strong></p>
<p>V8下的垃圾回收机制：</p>
<p>V8实现了准确式GC，GC算法采用了分代式垃圾回收机制，因此V8将内存（堆）分为<strong>新生代</strong>和<strong>老生代</strong>两部分</p>
<ul>
<li><p>新生代算法</p>
<p>新生代中的对象一般存活时间较短，使用 scavenge GC 算法</p>
<p>在新生代空间中，内存空间分为两部分，分别为<strong>from空间</strong>和<strong>to空间</strong>。在这两个空间中，必定有一个空间时使用的，另一个空间是空闲的。新分配的对象会被放入from空间中。当from空间被占满时，新生代GC就会启动了。算法会检查from空间中存活的对象并复制到to空间中，如果有失活的对象就会销毁。当复制完成后将from空间和to空间互换，这样GC就结束了</p>
</li>
<li><p>老生代算法</p>
<p>老生代中的对象一般存活事件较常切数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法</p>
<p>以下情况对象会出现在老生代空间中</p>
<ul>
<li>新生代中的对象已经历过一次scavenge算法</li>
<li>to空间中的对象占比大小超过25%，在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中</li>
</ul>
<p>在老生代中，以下情况会启动标记清楚算法</p>
<ul>
<li>某一空间没有分块的时候</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型堆内存时，可能需要几百毫秒才能完成一次标记，这就会导致一些性能上的问题。为了解决这个问题，2011年V8从stop-the-world标记切换到增量标记</p>
<p>清楚对象后会造成堆内存出现碎片的情况，当碎片超过一定先之后会启动压缩算法，在压缩过程中将蝴蝶对象向一端移动，直到所有对象都移动完成后清理掉不需要的内存</p>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>经典继承（构造函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">colors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = colors</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">colors</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, colors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s.colors);</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>​    可以传递构造参数</p>
<p>缺点：</p>
<ul>
<li>继承的方法都在构造函数中定义，构造函数不能够复用了</li>
<li>父类中定义的方法对于子类而言是不可见的</li>
</ul>
</li>
<li><p>原型继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  friends: [<span class="string">"jack"</span>, <span class="string">"linda"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = object(person)</span><br><span class="line">p1.name = <span class="string">"p1"</span></span><br><span class="line">p1.friends.push(<span class="string">"bob"</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Object</span>.create(person)</span><br><span class="line">p2.name = <span class="string">"p2"</span></span><br><span class="line">p2.friends.push(<span class="string">"lili"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);</span><br></pre></td></tr></table></figure>

<p>在<code>object</code>函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个实例。从本质上讲，<code>object()</code>将传入其中的对象执行了一次<strong>浅复制</strong></p>
<p>原型继承适用于只想让一个对象与另一个对象保持类似的情况</p>
</li>
<li><p>组合继承 👍</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类属性，第一次调用Father() </span></span><br><span class="line">  Father.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类方法，第二次调用Father()</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Son(<span class="string">"tom"</span>, <span class="number">21</span>)</span><br><span class="line">s1.colors.push(<span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.colors)</span><br><span class="line">s1.sayAge()</span><br><span class="line">s1.sayName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Son(<span class="string">"jack"</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s2.colors)</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生式继承</p>
<p>寄生式继承是与原型链继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// object(): 任何能返回新对象的函数</span></span><br><span class="line">    <span class="keyword">const</span> clone = object(original)</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        conosle.log(<span class="string">"hi"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生组合式继承 👍👍</p>
<p>组合继承的最大问题在于无论什么情况下都会调用两次父类型构造函数</p>
<p>寄生组合式继承即<strong>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="built_in">Object</span>.create(superType.prototype)</span><br><span class="line">  prototype.constructor = subType</span><br><span class="line">  subType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> SubType(<span class="string">"sub1"</span>, <span class="number">21</span>)</span><br><span class="line">sub1.sayAge()</span><br><span class="line">sub1.sayName()</span><br></pre></td></tr></table></figure>

</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/14/JavaScript相关-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/14/JavaScript相关-3/" class="post-title-link" itemprop="url">JavaScript相关-3</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-14 23:22:46 / 修改时间：23:23:32" itemprop="dateCreated datePublished" datetime="2020-02-14T23:22:46+08:00">2020-02-14</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>当执行JavaScript代码时，会产生三种执行上下文：</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code>执行上下文</li>
</ul>
<p>每个执行上下文中都有三种重要的属性：</p>
<ul>
<li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局执行上下文中访问（函数执行上下文中尉AO）</li>
<li>作用域链（Scope），JavaScript采用词法作用域，也就是说变量的作用域实在定义的时候就决定了，包含自身变量对象和上级变量对象的列表，通过<code>[[Scope]]</code>属性查找上级变量</li>
<li><code>this</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">globalContext.VO === global</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    foo: <span class="xml"><span class="tag">&lt;<span class="name">Function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">fooContext.AO === foo.AO</span></span><br><span class="line"><span class="xml">fooContext.AO = &#123;</span></span><br><span class="line"><span class="xml">    i: undefined,</span></span><br><span class="line"><span class="xml">    b: undefined,</span></span><br><span class="line"><span class="xml">    arguments: <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数独有的对象（箭头函数没有）</span></span><br><span class="line"><span class="xml">// 该对象时一个伪数组</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">fooContext.[[Scope]] = &#123;</span></span><br><span class="line"><span class="xml">    globalContext.VO</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">fooContext.Scope = fooContext.[[Scope]] + fooContext.VO</span></span><br><span class="line"><span class="xml">fooContext.Scope = [</span></span><br><span class="line"><span class="xml">    fooContext.VO,</span></span><br><span class="line"><span class="xml">    globalContext.VO</span></span><br><span class="line"><span class="xml">]</span></span><br></pre></td></tr></table></figure>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>通俗解释：</p>
<p>将声明的代码移动到了顶部</p>
<p>准确解释：👍</p>
<p>在生成执行上下文时，会有两个阶段</p>
<ol>
<li>创建的阶段（具体步骤是创建VO），JavaScript解释器会找出需要提升的变量和函数，并且给它们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量之生命并且赋值为<code>undefined</code></li>
<li>代码执行阶段（可以直接使用变量/函数）</li>
</ol>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>在一定时间多次触发但内只调用一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait = <span class="number">50</span>, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, context, args;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, params)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="keyword">this</span></span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/12/JavaScript相关-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/12/JavaScript相关-2/" class="post-title-link" itemprop="url">JavaScript相关-2</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-12 22:53:13" itemprop="dateCreated datePublished" datetime="2020-02-12T22:53:13+08:00">2020-02-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-18 10:44:40" itemprop="dateModified" datetime="2020-02-18T10:44:40+08:00">2020-02-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><strong>WHAT</strong></p>
<p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.</p>
<p>异步编程的一种解决方案</p>
<p><code>Promise</code>可能处于以下三个状态之一：<code>fulfilled</code>、<code>rejected</code>、<code>pending</code>。用户可以对<code>Promise</code>添加回调函数来处理操作成功的结果或失败的原因</p>
<p><strong>WHY</strong></p>
<p>传统的异步编程缺点难以忍受:</p>
<ul>
<li>代码臃肿</li>
<li>可读性差</li>
<li>耦合度过高，可维护性差</li>
<li>代码复用性差</li>
<li>只能在回调里处理异常</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">请求<span class="number">1</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    请求<span class="number">2</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">        请求<span class="number">3</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">3</span></span>)</span>&#123;</span><br><span class="line">            请求<span class="number">4</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">                请求<span class="number">5</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">5</span></span>)</span>&#123;</span><br><span class="line">                    请求<span class="number">6</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">6</span></span>)</span>&#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(请求<span class="number">1</span>)</span><br><span class="line">    .then(请求<span class="number">2</span>(请求结果<span class="number">1</span>))</span><br><span class="line">    .then(请求<span class="number">3</span>(请求结果<span class="number">2</span>))</span><br><span class="line">    .then(请求<span class="number">4</span>(请求结果<span class="number">3</span>))</span><br><span class="line">    .then(请求<span class="number">5</span>(请求结果<span class="number">4</span>))</span><br><span class="line">    .catch(处理异常(异常信息))</span><br></pre></td></tr></table></figure>

<p><strong>HOW</strong></p>
<p>常用API：</p>
<ul>
<li><p><code>Promise.resolve(value)</code></p>
<p>返回一个状态由给定的<code>value</code>决定的<code>Promise</code>对象。如果该值时<code>theable</code>（即带有then方法的对象），返回的<code>Promise</code>对象的最终状态是由<code>then</code>方法决定；否则（该<code>value</code>为空、基本类型或不带<code>then</code>方法的对象）返回的<code>Promise</code>对象状态为<code>fulfilled</code>，并且将该<code>value</code>传递给对应的<code>then</code>方法。通常，如果不知道一个值是否是<code>Promise</code>对象，可以使用<code>Promsie.resolve(value)</code>来返回一个<code>Promise</code>对象，这样就能将该<code>value</code>以<code>Promise</code>对象形式使用</p>
</li>
<li><p><code>Promise.reject(value)</code></p>
<p>返回一个状态为失败的<code>Promise</code>对象，并将给定的失败信息传递给对应的出处理方法</p>
</li>
<li><p><code>Promise.race(interable)</code></p>
<p>当<code>interable</code>参数里的任意一个子<code>promise</code>被执行失败或成功后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promsie</code>绑定的相应句柄并返回该<code>promsie</code>对象</p>
</li>
<li><p><code>Promise.all(interable)</code></p>
<p>这个方法返回的是一个新的<code>promise</code>对象，该<code>promise</code>对象在<code>interable</code>参数对象里所有的<code>promise</code>对象都成功的时候才会触发成功，一旦有任何一个<code>interable</code>里的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>interable</code>里所有<code>promise</code>返回值的数组作为成功回调的返回值，顺序跟<code>interable</code>的顺序保持一致；如果这个新的<code>promise</code>对象出发了失败状态，它会把<code>interable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。<code>Promise.all</code>方法常用于处理多个<code>promise</code>对象的状态集合</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">"./index.html"</span>, &#123; <span class="attr">encoding</span>: <span class="string">"utf8"</span> &#125;, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err, data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_readFile</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">"./index.html"</span>, options, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(err)</span><br><span class="line">        reject(err)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> _readFile(<span class="string">"./index.html"</span>, <span class="string">"utf8"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="遍历对象的属性和数组元素的方法"><a href="#遍历对象的属性和数组元素的方法" class="headerlink" title="遍历对象的属性和数组元素的方法"></a>遍历对象的属性和数组元素的方法</h2><p>对象：</p>
<ul>
<li><p><code>for</code>循环 👎</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> obj)</span><br><span class="line">    <span class="built_in">console</span>.log(property)</span><br></pre></td></tr></table></figure>

<p>缺点：会遍历到它的继承属性，在使用之前需要加入<code>obj.hasOwnProperty(property)</code></p>
</li>
<li><p><code>Object.keys(obj).forEach()</code> 👍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">property</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(property)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Object.keys</code>返回一个有给定对象的自身可枚举属性组成的数组</p>
</li>
<li><p><code>Object.getOwnPropertyNames(obj).forEach</code> 👍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="function"><span class="params">property</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(property)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyNames</code>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括<code>Symbol</code>值作为名称的属性）组成的数组</p>
</li>
<li><p><code>Reflect.ownKeys(target)</code> 👍</p>
<p>基本等同于<code>Object.getOwnPeopertyNames</code> + <code>Object.getOwnPropertySymbols</code></p>
</li>
</ul>
<p>数组：<strong>各取所需</strong></p>
<ul>
<li><p><code>for</code>循环</p>
<p>普通遍历方法，较常用</p>
</li>
<li><p><code>arr.forEach</code></p>
<p>相较于<code>for</code>，<code>forEach</code>不可提前结束循环</p>
</li>
<li><p><code>arr.map/reduce</code></p>
</li>
</ul>
<h2 id="可变对象和不可变对象"><a href="#可变对象和不可变对象" class="headerlink" title="可变对象和不可变对象"></a>可变对象和不可变对象</h2><p><strong>可变对象</strong>在创建之后是可以被改变的</p>
<p><strong>不可变对象</strong>在创建之后是不可以被改变的</p>
<ol>
<li>在<code>JavaScript</code>中，<code>string</code>和<code>number</code>从设计之初就是不可变的（immediate）</li>
<li>不可变对象是保持一个对象状态不变，这样的好处是是的开发更加简单、可回溯、测试友好，减少了任何可能的副作用。但是，每当想添加点东西到一个不可变对象里时，它一定是先拷贝已存在的值到新实例里，然后再给新实例添加内容，最后返回新实例。相比可变对象，这势必会有更多内存、计算量消耗</li>
</ol>
<p>创建一个纯函数（pure function）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    school: <span class="string">"baidu"</span>,</span><br><span class="line">    name: <span class="string">"tom"</span>,</span><br><span class="line">    age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateStudent</span>(<span class="params">student, name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...student,</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步函数和异步函数"><a href="#同步函数和异步函数" class="headerlink" title="同步函数和异步函数"></a>同步函数和异步函数</h2><p>同步函数阻塞，异步函数不阻塞。在同步函数中，语句完成后下一句才执行，在这种情况下，程序可以按照语句的顺序进行精确评估，如果其中一个语句需要很长时间，那么程序的执行会停滞很长时间</p>
<p>异步函数通常接受回调作为参数，在调用异步函数后立即继续执行下一行。回调函数仅在异步操作完成且调用堆栈为空时调用，诸如从web服务器加载数据或查询数据库等重负载操作应该异步完成，以便主线程可以继续执行其他操作而不会出现一直阻塞</p>
<p>在JavaScript中异步函数的解决方案通常有callback、Promise、async/await</p>
<h2 id="JavaScript执行机制"><a href="#JavaScript执行机制" class="headerlink" title="JavaScript执行机制"></a>JavaScript执行机制</h2><ul>
<li><p><strong>JavaScript的执行与运行</strong></p>
<p>执行和与运行不太相同，在不同环境下，比如Node、浏览器下，JavaScript的执行结果是不一样的；而运行大多是指基于JavaScript引擎，如V8，结果是一致的 </p>
</li>
<li><p><strong>关于JavaScript</strong></p>
<p>众所周知，JavaScript是一门<strong>单线程</strong>、<strong>异步执行</strong>的语言，虽然在HTML5中提出了<strong>web workers</strong>（可以理解为<strong>浏览器</strong>为JavaScript开的“外挂”），但JavaScript是单线程运行的这一核心仍未改变，所有多线程都是通过单线程<strong>模拟</strong>出来的</p>
</li>
<li><p><strong>JavaScript中的异步</strong> <strong>event-loop</strong></p>
<p>JavaScript中的异步主要通过<strong>event loop</strong>进行模拟当我们执行JavaScript代码的时候其实就是往执行栈中放入函数，那么遇到异步代码怎么办？其实当遇到异步代码时，会被挂起并在需要执行的时候加入到<strong>Task</strong>（有多种Task）队列中。一旦执行栈为空，<strong>event loop</strong>就会从<strong>Task</strong>中拿出需要执行的代码并放入执行栈中执行，所以本质上说JavaScript中的异步还是同步行为</p>
</li>
<li><p><strong>浏览器中的event loop</strong></p>
<p>来自不同的<strong>任务源</strong>的任务会被分配到不同的Task队列中，任务源可以分为<strong>微任务（micro task）</strong>和<strong>宏任务（macro task）</strong>。在ES6规范中，微任务被称为jobs，宏任务被称为task</p>
<p>微任务包括：<code>precess.nextTick</code>、<code>promise</code>、<code>Mutation Observer</code></p>
<p>宏任务包括：<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>I/O</code>、UI Rendering</p>
<p><strong>宏任务中包含了<code>script</code>，因此浏览器会先执行一个宏任务，接下来由异步代码的话才会先执行微任务</strong></p>
<p><strong>event loop执行顺序</strong>：</p>
<ol>
<li>先执行同步代码，这属于宏任务</li>
<li>当<strong>执行完所有同步代码</strong>后执行栈为空，查询是否有异步代码需要执行</li>
<li><strong>执行所有微任务</strong></li>
<li>当执行完所有微任务，如有必要会渲染页面</li>
<li>然后开始下一轮<code>event loop</code>，执行宏任务中的异步代码也就是<code>setTimeout</code>（宏任务）中的回调函数</li>
</ol>
<p><img src="./imgs/browser_event_loop.png" alt="浏览器中的event loop"></p>
<p><img src="./imgs/browser_event_loop2.png" alt="浏览器中的event loop"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  resolve(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 4 7 5 2 3 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Node.js中的event loop</strong></p>
<p>Node.js中的<code>event loop</code>分为6个阶段，他们会按照顺序反复运行。每当进入某一个阶段的时候都会从对应的回调队列中取出函数去执行。当<strong>队列为空</strong>或者<strong>执行的回调函数数量到达系统设定的阈值</strong>，就会进入下一阶段</p>
<p><img src="./imgs/node_event_loop.png" alt="Node.js中的event loop"></p>
<ol>
<li><p><strong>timers</strong></p>
<p><strong>timers</strong>阶段会执行<code>setTimeout</code>和<code>setinterval</code>回调，并且是由<strong>poll</strong>阶段控制的。同样在<code>Node.js</code>中定时器指定的事件也不是准确时间，只是尽快执行</p>
</li>
<li><p><strong>I/O</strong></p>
<p><strong>I/O</strong>阶段会处理一些上一轮循环中少许未执行的<strong>I/O</strong>回调</p>
</li>
<li><p><strong>idle,prepare</strong></p>
</li>
<li><p><strong>poll</strong></p>
<p><strong>poll</strong>是一个至关重要的阶段，在这一阶段中，系统会做两件事情</p>
<ol>
<li><p>回到<strong>timer</strong>阶段执行回调</p>
</li>
<li><p>执行<strong>I/O</strong>回调，并且在进入该阶段时如果没有设定了<strong>timer</strong>的话，会发生以下两件事情</p>
</li>
</ol>
<ul>
<li>如果<strong>poll</strong>队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果<strong>poll</strong>队列为空<ul>
<li>如果有<code>setImmediate</code>回调需要执行，<strong>poll</strong>阶段会停止并且<strong>进入到check阶段</strong>执行回调</li>
<li>如果没有，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间防止一直等待下去</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>check</strong></p>
<p>执行<code>setImmediate</code></p>
</li>
<li><p><strong>close callbacks</strong></p>
<p>执行close事件</p>
</li>
</ol>
<p><img src="./imgs/node_event_loop2.png" alt="Node.js中的event loop"></p>
</li>
</ul>
<h2 id="ES6的类和ES6的构造函数的区别"><a href="#ES6的类和ES6的构造函数的区别" class="headerlink" title="ES6的类和ES6的构造函数的区别"></a>ES6的类和ES6的构造函数的区别</h2><p>在普通使用中没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要区别在于类继承上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype)</span><br><span class="line">Student.prototype.constructor = Student</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    consreuctor(name, id) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符和剩余参数语句的区别"><a href="#扩展运算符和剩余参数语句的区别" class="headerlink" title="扩展运算符和剩余参数语句的区别"></a>扩展运算符和剩余参数语句的区别</h2><p>在函数泛型编码时，ES6的扩展运算符非常有用吗，因为我们可以轻松创建数组和对象的拷贝，而无需使用<code>Object.create</code>、<code>slice</code>或其他函数库。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [ ...arr, <span class="string">"test"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = test([<span class="string">"hello"</span>, <span class="string">"world"</span>])</span><br><span class="line"><span class="comment">// ["hello", "world", "test"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"tom"</span>,</span><br><span class="line">    age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copyPerson = &#123; ...person &#125;</span><br></pre></td></tr></table></figure>

<p>ES6的剩余参数语句提供了一个简写，允许我们将不定数量的参数表示为一个<strong>数组</strong>，它就像扩展运算符语法的反面，将数据收集到数组中而不是解构数组。剩余参数语句在函数参数、数组和对象的解构赋值中有很大作用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [6, 7, 8, 9]</span></span><br><span class="line"><span class="keyword">const</span> result2 = test(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="comment">// [10, 11, 12, 13, 14]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ a, b, ...rest ] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">// 1 2 [ 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>JavaScript中分为<strong>七种</strong>内置类型，其中内置类型又分为两大类型：<strong>基本类型</strong>和<strong>引用类型</strong>（对象 Object）</p>
<p>基本类型：<code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></p>
<p>其中JavaScript的数字类型是浮点类型的，没有整形。并且浮点类型基于 IEEE 754 标准实现，在使用中会遇到某些 <a href="#2">Bug </a><code>NaN</code>也属于<code>number</code>类型并且<code>NaN</code>并不等于自身</p>
<p>对于基本类型来说，如果使用字面量的方式，那个这个变量只是个字面量，只有在必要的时候才会转换成对应的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">111</span> <span class="comment">// 这只是字面量，不是number类型</span></span><br><span class="line">a.toString() <span class="comment">// 使用的时候才会转换为对象类型</span></span><br></pre></td></tr></table></figure>

<p>引用类型在使用过程中会遇到深拷贝和浅拷贝问题</p>
<h2 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h2><p><code>typeof</code>对于基本类型，除了<code>null</code>都可以显示正确的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code>对于对象，除了函数都会显示<code>object</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>关于为什么<code>typeof null == object</code>：在JavaScript的最初版本中，使用的是32为系统，为了性能考虑使用低位存储了变量的类型信息。<code>000</code>开头的代表是对象，然而<code>null</code>表示为全零，所以将它错误的判断为<code>object</code></p>
<p>如果想得到一个正确的数据类型，使用<code>Object.prototype.toString.call(xxx)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instance</code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能正确的找到类型的<code>prototype</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    left = left.__proto__</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (prototypr === left)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>在调用<code>new</code>的过程中会发生以下四件事情</p>
<ol>
<li>新生成了一个对象</li>
<li>绑定到原型</li>
<li>绑定<code>this</code></li>
<li>返回新对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/11/JavaScript相关-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/11/JavaScript相关-1/" class="post-title-link" itemprop="url">JavaScript相关-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-11 23:33:22" itemprop="dateCreated datePublished" datetime="2020-02-11T23:33:22+08:00">2020-02-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 23:16:12" itemprop="dateModified" datetime="2020-02-12T23:16:12+08:00">2020-02-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h2><p><code>document.write()</code> 方法将一个文本字符串写入一个由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/open" target="_blank" rel="noopener"><code>document.open()</code></a> 打开的文档流（document stream）。（<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/write" target="_blank" rel="noopener">MDN</a>）</p>
<p>作用：</p>
<p>加载只有启用JavaScript后的样式文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.open()</span></span><br><span class="line"><span class="xml">    docuemnt.write('<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style_neads_js.css"</span> /&gt;</span>')</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.close()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>弊端：</p>
<ul>
<li>在非loading阶段使用<code>docuemnt.write</code>会清除已加载的页面</li>
<li><code>docuemnt.write</code>不能够在XHTML中使用</li>
<li>嵌入script中的<code>docuemnt.write</code>不能给任意节点添加子节点，因为它是随着DOM的构建执行的</li>
<li>利用<code>docuemnt.write</code>写入HTML字符流并不是一个好方法，它有违DOM操作的概念</li>
<li>利用<code>docuemnt.write</code>添加script加载外部脚本时，浏览器的HTML解析会被script的加载所阻塞</li>
</ul>
<h2 id="功能检测（feature-detection）、功能推断（feature-inference）、和使用UA字符串之间有什么区别"><a href="#功能检测（feature-detection）、功能推断（feature-inference）、和使用UA字符串之间有什么区别" class="headerlink" title="功能检测（feature detection）、功能推断（feature inference）、和使用UA字符串之间有什么区别"></a>功能检测（feature detection）、功能推断（feature inference）、和使用UA字符串之间有什么区别</h2><p>功能检测（feature detection） 👍</p>
<p>功能检测包括确定浏览器是否支持某段代码，以及是否能运行不同的代码（取决于它是否执行），一边浏览器能始终正确运行代码功能，而不会在某些浏览器中出现崩溃和错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"geolocation"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="comment">// 可以使用 navigator.geolocation</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 navigator.geolocation 功能缺失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能推断（feature inference）👎</p>
<p>功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后还会使用其他功能，因为它假设其他功能也可用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementsByTagName) &#123;</span><br><span class="line">  element = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UA 👎</p>
<p>这是一个浏览器报告的字符串，它允许网络协议对等方（network protocol peers）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过<code>navigator.userAgent</code>访问。然而，这个字符串很可能存在欺骗性，例如，chrome会同时作为chrome和safari进行报告，因此，要检测safari，除了检查safari字符串，还要检查是否同时存在chrome字符串。</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p><strong>WHAT</strong></p>
<p>Ajax（asynchronous JavaScript and XML）是使用客户端上的许多web技术，创建异步web应用的一种<strong>技术结合体</strong>。借助Ajax，web应用可以<strong>异步</strong>（在后台）向服务器发送数据可从服务器检索数据而不会干扰现有页面的显示和行为。通过将<strong>数据交互层与表示层分离</strong>，Ajax允许网页和扩展web应用程序动态更改内容而<strong>不需重新加载整个页面</strong>，实际上，现在通常将XML替换为JSON，因为JavaScript对JSON有原生支持优势</p>
<p><strong>WHY</strong></p>
<p>优点：</p>
<ul>
<li>交互性更好，来自服务器的新内容可以动态更改，无需重新加载整个页面</li>
<li>减少与服务器的连接，因为脚本和样式只需要被请求一次</li>
<li>状态可以维护在一个页面上，JavaScript变量和DOM状态将的到保持，因为主容器页面未被重新加载</li>
<li>基本上包含大部分SPA的优点</li>
</ul>
<p>缺点</p>
<ul>
<li>动态网页很难收藏</li>
<li>如果JavaScript在浏览器中被禁用则不起作用</li>
<li>有些网络爬虫不执行JavaScript，也不会看到JavaScript加载的内容</li>
</ul>
<p><strong>HOW</strong></p>
<ul>
<li>使用<code>CSS</code>和<code>XHTML</code>来表示</li>
<li>使用<code>DOM</code>模型来交互和动态显示</li>
<li>使用<code>XMLHttpRequest</code>来和服务器进行异步通信</li>
<li>使用<code>JavaScript</code>来绑定和调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = &#123;&#125;;</span><br><span class="line">ajax.httpRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> versions = [</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.6.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.5.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.4.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.3.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XmlHttp.2.0"</span>,</span><br><span class="line">        <span class="string">"Microsoft.XmlHttp"</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> xhr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; versions.length; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ajax.send = <span class="function"><span class="keyword">function</span> (<span class="params">url, callback, method, data, async</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">async</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">async</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> httpRequest = ajax.httpRequest();</span><br><span class="line">    httpRequest.open(method, url, <span class="keyword">async</span>);</span><br><span class="line">    httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (httpRequest.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">            callback(httpRequest.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        httpRequest.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    httpRequest.send(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ajax.get = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> query = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    ajax.send(url + (query.length ? <span class="string">'?'</span> + query.join(<span class="string">'&amp;'</span>) : <span class="string">''</span>), callback, <span class="string">'GET'</span>, <span class="literal">null</span>, <span class="keyword">async</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ajax.post = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> query = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    ajax.send(url, callback, <span class="string">'POST'</span>, query.join(<span class="string">'&amp;'</span>), <span class="keyword">async</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><strong>WHAT</strong></p>
<p>带填充的json（p for padding），是一种通常用于绕过浏览器中的跨域选址的方法，因为Ajax不允许跨域请求。</p>
<p>原理：利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据。</p>
<p><strong>WHY</strong></p>
<p>解决跨域（只适用于GET请求）</p>
<p><strong>HOW</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsonp.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, cb &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">        <span class="built_in">window</span>[cb] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(script)</span><br><span class="line">        &#125;</span><br><span class="line">        params = &#123; ...params, cb &#125;</span><br><span class="line">        <span class="keyword">let</span> tmp = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params)</span><br><span class="line">            tmp.push(<span class="string">`<span class="subst">$&#123; key &#125;</span>=<span class="subst">$&#123; params[key] &#125;</span>`</span>)</span><br><span class="line">        script.src = <span class="string">`<span class="subst">$&#123; url &#125;</span>?<span class="subst">$&#123; tmp.join(<span class="string">"&amp;"</span>) &#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(&#123; </span><br><span class="line">    url: <span class="string">"http://localhost:3000/say"</span>,</span><br><span class="line">    params: &#123; <span class="attr">wd</span>: <span class="string">"hello jsonp"</span> &#125;,</span><br><span class="line">    cb: <span class="string">"show"</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">"/say"</span>, (res, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; wd, cb &#125; = req.query</span><br><span class="line">    res.end(<span class="string">`<span class="subst">$&#123;cb&#125;</span>('i am fine, and you?')`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升（hoisting）用于解释代码中变量声明行为的术语。使用<code>var</code>关键字声明或初始化的变量会将声明语句“提升”到当前作用域的顶部。但是只有声明才会触发提升，赋值语句将保持原样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// ReferenceError: bar is not defined</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line">foo(); <span class="comment">// 'foo'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// [Function: foo]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// undefined</span></span><br><span class="line">bar(); <span class="comment">// Uncaught TypeError: bar is not a function</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// [Function: bar]</span></span><br></pre></td></tr></table></figure>

<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>当一个事件在DOM元素上触发时，如果有时间监听器，它尝试处理该事件，然后事件冒泡到其父级元素，并发生同样的事情，最后直至到达祖先元素。时间冒泡机制是实现事件委托（event delegation）的原理</p>
<h2 id="attribute和property"><a href="#attribute和property" class="headerlink" title="attribute和property"></a>attribute和property</h2><p>attribute是在HTML中定义的，而property实在DOM上定义的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input1"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"hello"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input1"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.getAttribute(<span class="string">"value"</span>)) <span class="comment">// hello</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.value) <span class="comment">// hello</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 当在文本框中输入 ‘world’ 后</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.getAttribute(<span class="string">"value"</span>)) <span class="comment">// hello</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.value) <span class="comment">// world</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="document的load事件和DOMContentLoaded事件之间的区别"><a href="#document的load事件和DOMContentLoaded事件之间的区别" class="headerlink" title="document的load事件和DOMContentLoaded事件之间的区别"></a>document的load事件和DOMContentLoaded事件之间的区别</h2><p>DOMContentLoaded：👍</p>
<p>当初始的HTML文档本完全加载和解析完成之后，DOMContentLoaded事件被触发而无需等待样式表、图像和子框架的完成加载</p>
<p>load：</p>
<p>window的load事件仅在DOM和所有相关资源全部完成加载后才会触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"DOMContentLoaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"window loaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOMContentLoaded</span></span><br><span class="line"><span class="comment">// window loaded</span></span><br></pre></td></tr></table></figure>

<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是由Netscape提出的一个著名的安全策略，浏览器出于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读取对方的资源。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源的定义:</a></p>
<p>如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的<strong>源</strong>。我们也可以把它称为“协议/主机/端口 tuple”，或简单地叫做“tuple”. (“tuple” ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元)</p>
<p>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>http://store.company.com/dir2/other.html</code></td>
<td>成功</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><code>http://store.company.com/dir/inner/another.html</code></td>
<td>成功</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><code>https://store.company.com/secure.html</code></td>
<td>失败</td>
<td>协议不同</td>
</tr>
<tr>
<td><code>http://store.company.com:81/dir/etc.html</code></td>
<td>失败</td>
<td>端口不同</td>
</tr>
<tr>
<td><code>http://news.company.com/dir/other.html</code></td>
<td>失败</td>
<td>域名不同</td>
</tr>
</tbody></table>
<h2 id="JavaScript严格模式"><a href="#JavaScript严格模式" class="headerlink" title="JavaScript严格模式"></a>JavaScript严格模式</h2><p><strong>WHAT</strong></p>
<p>ES5最早引入了“严格模式”（strict mode）的概念。可选择的一个限制JavaScript的变体的一种方式</p>
<p><strong>WHY</strong></p>
<p>优点：</p>
<ul>
<li>无法再意外创建全局变量</li>
<li>会引起静默失败（sliently fail， 即：不报错也没有任何效果）的操作抛出异常<ul>
<li>对变量调用<code>delete</code>操作符</li>
<li>为只读属性赋值</li>
<li>对不可配置（nonconfigurable）的属性使用<code>delete</code>操作符</li>
</ul>
</li>
<li>试图删除不可删除的属性时会抛出异常</li>
<li>要求函数的参数名唯一</li>
<li>某些保留字（<code>interface</code>、<code>implements</code>、<code>package</code>等）不能作为变量名</li>
<li>抑制<code>this</code><ul>
<li>全局作用域下，<code>this</code>的值为<code>undefined</code></li>
<li><code>.call()</code>、<code>.apply()</code>传递错误的<code>this</code>会报错（非严格模式下会转换为全部对象）</li>
</ul>
</li>
<li>捕获了一些常见的编码错误，并抛出异常</li>
</ul>
<p>缺点：</p>
<ul>
<li>确实许多开发人员已经习惯的功能</li>
<li>无法访问<code>function.caller</code>和<code>function.arguments</code></li>
<li>以不同严格模式编写的脚本合并后可能会导致问题</li>
</ul>
<p><strong>HOW</strong></p>
<p>在需要启用严格模式的<strong>代码</strong>顶部添加：<code>&quot;use strict;&quot;</code></p>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p><strong>WHAT</strong></p>
<p>single page application 单页面应用</p>
<p>现如今，web程序员将他们构建的产品成为web应用而不是网站。虽然这两个术语之间没有严格的区别，但网络应用往往具有高度的交互性和动态性，允许用户执行操作并接受他们的操作响应。在过去，浏览器从服务器接收HTML并渲染，当用户导航到其他URL时，需要整页刷新，服务器会为新页面发送新的HTML，这被称为服务端渲染</p>
<p>然而，在现代的SPA中，客户端渲染取而代之。浏览器从都武器加载<strong>初始页面</strong>，整个应用程序所所需的脚本（库、框架、应用代码）和样式表。当用户导航到其他页面时，<strong>不会触发页面刷新</strong>，该页面的URL通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">HTML5 History API</a>进行更新。浏览器通过Ajax请求向服务器检索所需的数据（通常采用json格式），然后SPA<strong>通过JavaScript来动态更新页面</strong>，这些JavaScript在初始页面已经下载。这种模式类似于原生移动应用的工作方式。</p>
<p><img src="./imgs/spa.png" alt="SPA"></p>
<p><strong>WHY</strong></p>
<p>好处：</p>
<ul>
<li>用户感知响应更快，用户切换页面时不会再看到因页面刷新而导致的白屏</li>
<li>对服务器进行的HTTP请求减少，因为对于没和页面的加载不必再次下载相同的资源</li>
<li>客户端和服务端之间的关注点分离，可以为不同平台（手机、智能手表）建立新的客户端而不需修改服务器代码。</li>
</ul>
<p>弊端：</p>
<ul>
<li>由于加载了多个页面需要的框架、应用代码和资源导致初始页面加载时间过长</li>
<li>服务器还需额外的工作将是所有路由请求配置到单个入口点，然后由客户端接管路由</li>
<li>SPA依赖于JavaScript来渲染页面，对SEO不友好</li>
</ul>
<p><strong>HOW</strong></p>
<ol>
<li>向服务器请求初始页面并渲染，同时请求整个应用所需的脚本、样式</li>
<li>监听用户操作：<ul>
<li>通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">HTML5 History API</a>进行页面导航</li>
<li>通过Ajax向服务器请求数据并使用JavaScript动态渲染到页面上</li>
</ul>
</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/02/10/JavaScript相关-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/02/10/JavaScript相关-0/" class="post-title-link" itemprop="url">JavaScript相关-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-10 23:18:10" itemprop="dateCreated datePublished" datetime="2020-02-10T23:18:10+08:00">2020-02-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 23:16:00" itemprop="dateModified" datetime="2020-02-12T23:16:00+08:00">2020-02-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件委托-（event-delegation）"><a href="#事件委托-（event-delegation）" class="headerlink" title="事件委托 （event delegation）"></a>事件委托 （event delegation）</h2><p>事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器，当触发子元素时，事件会冒泡到父元素，监听器就会触发，这种技术的好处是：</p>
<ol>
<li>内存占用少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。</li>
<li>无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。</li>
</ol>
<h2 id="JavaScript中的this指向"><a href="#JavaScript中的this指向" class="headerlink" title="JavaScript中的this指向"></a>JavaScript中的this指向</h2><p>简单来讲，<code>this</code>的指向取决于函数的调用方式</p>
<ol start="0">
<li>如果是箭头函数，<code>this</code>被设置为调用时的上下文</li>
<li>如果使用<code>new</code>，函数内的<code>this</code>是一个全新的对象</li>
<li>如果<code>apply、call、bind</code>方法用于调用/创建一个函数，函数内的<code>this</code>就是作为参数传入这些方法的对象</li>
<li>当函数作为对象里的方法被调用时，函数内的<code>this</code>是调用该函数的对象，比如当<code>obj.method()</code>被调用时，函数内的<code>this</code>将绑定到<code>obj</code>对象</li>
<li>如果不符合上述规则，那么<code>this</code>的值指向全局对象<code>global object</code>，浏览器环境下<code>this</code>的值指向<code>window</code>对象，但在严格模式下<code>use strict</code>，<code>this</code>的值为<code>undefined</code></li>
<li>如果符合上述多个规则，从上到下权重依次递减</li>
</ol>
<h2 id="原型继承-prototypal-inheritance"><a href="#原型继承-prototypal-inheritance" class="headerlink" title="原型继承 prototypal inheritance"></a>原型继承 <code>prototypal inheritance</code></h2><p>所有的JS对象都有一个<code>prototype</code>对象，指向它的原型对象，当试图访问一个对象的属性时，如果没有在该对象上找到它还会搜索该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或达到原型链的末尾。这种行为是在模拟经典的继承，但与其说时继承还不如说是委托<code>delegation</code></p>
<p>读取对象的属性值时，会自动到原型链中查找</p>
<p>设置对象的属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值</p>
<p><img src="./imgs/1581317824537.png" alt="原型"></p>
<h2 id="JavaScript的模块化机制"><a href="#JavaScript的模块化机制" class="headerlink" title="JavaScript的模块化机制"></a>JavaScript的模块化机制</h2><ul>
<li><p>AMD</p>
<p><strong>Asynchronous Module Definition 异步模块加载机制</strong>，ReqireJS实现了AMD规范</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="comment">//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="comment">//数组中声明需要加载的模块，可以是模块名、js文件路径</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>对于依赖的模块，AMD推崇<strong>依赖前置，提前执行</strong>，也就是说，在<code>define</code>方法里传入的依赖模块（数组）会在一开始就下载并执行。适合在<strong>浏览器端</strong>使用</p>
</li>
<li><p>CommonJS</p>
<p>CommonJS规范为CommonJS小组所提出，目的是弥补JavaScript在服务器端缺少模块化机制，<strong>NodeJS、webpack</strong>都是基于该规范来实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"></span><br><span class="line">a();<span class="comment">//"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a2.js</span></span><br><span class="line">exports.num = <span class="number">1</span>;</span><br><span class="line">exports.obj = &#123;<span class="attr">xx</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2.js</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="built_in">require</span>(<span class="string">'./a2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a2);<span class="comment">//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>所有代码都运行在<strong>模块作用域</strong>，不会污染全局作用域</li>
<li>模块是<strong>同步加载</strong>的，即只有加载完成才能执行后面的操作</li>
<li>模块在首次执行后就会<strong>缓存</strong>，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的是被输出的<strong>值的拷贝</strong>，模块内部的变化也不会影响这个值</li>
</ul>
</li>
<li><p>ES6 Module</p>
<p>ES6 Module是<strong>ES6</strong>中规定的模块体系</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'lin'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">var</span> job = <span class="string">'ninja'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, age, job&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, job&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, age, job);<span class="comment">// lin 13 ninja</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a2.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'default '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./a2.js'</span>;</span><br><span class="line">customName(); <span class="comment">// 'default'</span></span><br></pre></td></tr></table></figure>

<p>特点（对比CommonJS）：</p>
<table>
<thead>
<tr>
<th></th>
<th>CommonJS</th>
<th>ES6 Module</th>
</tr>
</thead>
<tbody><tr>
<td>加载时间</td>
<td>运行时加载</td>
<td>编译时输出接口</td>
</tr>
<tr>
<td>加载方式</td>
<td>加载整个模块</td>
<td>按需加载</td>
</tr>
<tr>
<td>输出方式</td>
<td>值的拷贝</td>
<td>值的引用</td>
</tr>
<tr>
<td>this</td>
<td>指向当前模块</td>
<td>undefined</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h2><ul>
<li><p>WHAT</p>
<p>定义：</p>
<ol>
<li><p>即使被外部函数返回，依然可以访问到外部（封闭）函数作用域的<strong>函数</strong>。</p>
</li>
<li><p>包含被引用变量（函数）的<strong>对象</strong></p>
</li>
</ol>
<p>生命周期：</p>
<p>​    产生：在嵌套内部函数<strong>定义执行完</strong>时就产生了（<strong>不是在调用</strong>）</p>
<p>​    死亡：在嵌套内部函数成为垃圾对象时</p>
</li>
<li><p>WHY</p>
<ul>
<li><p>可以实现数据私有化或特权方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter1 = count()</span><br><span class="line"><span class="built_in">console</span>.log(counter1());</span><br><span class="line"><span class="built_in">console</span>.log(counter1());</span><br><span class="line"><span class="built_in">console</span>.log(counter1());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"---------"</span>);</span><br><span class="line"><span class="keyword">let</span> counter2 = count()</span><br><span class="line"><span class="built_in">console</span>.log(counter2());</span><br><span class="line"><span class="built_in">console</span>.log(counter2());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ----new counter-----</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现单例模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">  test () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ()()的作用：使函数立即调用一次</span></span><br><span class="line"><span class="comment">// 闭包的作用：私有化变量</span></span><br><span class="line">Single.getIntance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Single()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分参数函数（partial applications）柯里化（currying）</p>
<p>函数式编程-柯里化</p>
</li>
</ul>
</li>
<li><p>HOW</p>
<p>常见的创建闭包的方式是在一个函数内部创建另一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">12</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test"</span>, a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="foreach和-map的区别"><a href="#foreach和-map的区别" class="headerlink" title=".foreach和.map的区别"></a><code>.foreach</code>和<code>.map</code>的区别</h2><ul>
<li>都是用来遍历一个数组</li>
<li><code>foreach</code>对原数组有副作用，而<code>map</code>则会返回一个新的数组</li>
</ul>
<h2 id="匿名函数的使用场景"><a href="#匿名函数的使用场景" class="headerlink" title="匿名函数的使用场景"></a>匿名函数的使用场景</h2><ul>
<li><p>在IIFE中使用,用来封装局部作用域内的代码，避免污染全局作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以作为回调函数，简洁易读</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">settimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用作函数式编程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.map(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="宿主对象（host-objects）和原生对象（native-objects）的区别"><a href="#宿主对象（host-objects）和原生对象（native-objects）的区别" class="headerlink" title="宿主对象（host objects）和原生对象（native objects）的区别"></a>宿主对象（host objects）和原生对象（native objects）的区别</h2><ul>
<li>原生对象是由ECMAScript规范定义的JavaScript内置对象，如<code>String</code>、<code>Math</code>、<code>RegExp</code>等</li>
<li>宿主对象是指由运行时环境（浏览器或Node）提供，如<code>window</code>、<code>XMLRequest</code>、<code>Buffer</code></li>
</ul>
<h2 id="function-Persion-、var-person-Person-、var-person-new-Person-的区别"><a href="#function-Persion-、var-person-Person-、var-person-new-Person-的区别" class="headerlink" title="function Persion() {}、var person = Person()、var person = new Person()的区别"></a><code>function Persion() {}</code>、<code>var person = Person()</code>、<code>var person = new Person()</code>的区别</h2><p><code>function Persion() {}</code>只是一个普通的函数声明。使用PascalCase方式命名的函数作为构造函数是一种惯例</p>
<p><code>var person = Person()</code>将<code>Person</code>作为普通函数调用而不是构造函数。如果该函数是用作构造函数，那么这种调用方式是一种创建错误，通常情况下构造函数不会返回任何东西，因此向普通函数一样调用构造函数只会返回<code>undefined</code></p>
<p><code>var person = new Person()</code>使用<code>new</code>操作符，创建<code>Person</code>对象的实例，该实例继承自<code>Person.prototype</code><br>在使用new的过程中会发生以下事情：</p>
<ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定this</li>
<li>返回新对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = Person()</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"tom"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Person &#123; name: "tom" &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="call和-apply的区别"><a href="#call和-apply的区别" class="headerlink" title=".call和.apply的区别"></a><code>.call</code>和<code>.apply</code>的区别</h2><table>
<thead>
<tr>
<th></th>
<th><code>call</code></th>
<th><code>apply</code></th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>指定函数<code>this</code></td>
<td>指定函数<code>this</code></td>
</tr>
<tr>
<td>传参方式</td>
<td>以逗号分隔</td>
<td>数组</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> leo = &#123;</span><br><span class="line">	name: <span class="string">"Leo"</span>,</span><br><span class="line">	sayHi() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Hi! I'm "</span> + <span class="keyword">this</span>.name) </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> neil = &#123;</span><br><span class="line">	name: <span class="string">"Neil"</span></span><br><span class="line">&#125;;</span><br><span class="line">leo.sayHi(); <span class="comment">// "Hi! I'm Leo"</span></span><br><span class="line">leo.sayHi.call(neil); <span class="comment">// "Hi! I'm Neil"</span></span><br><span class="line">leo.sayHi.call(<span class="literal">null</span>); <span class="comment">// "Hi! I'm undefined"</span></span><br><span class="line"><span class="keyword">var</span> neilSayHi = leo.sayHi.bind(neil)</span><br><span class="line">consolo.log(<span class="keyword">typeof</span> neilSayHi)  <span class="comment">// function</span></span><br><span class="line">nei.sayHi() <span class="comment">// "Hi! I'm Neil"</span></span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><code>bind</code></h2><p>也用于改变<code>this</code>的只想相较于<code>call</code>、<code>apply</code>，<code>bind</code>返回的是一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">test.bind(&#123; <span class="attr">x</span>: <span class="number">100</span> &#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/01/14/Node.js-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/01/14/Node.js-基础/" class="post-title-link" itemprop="url">Node.js-基础</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-01-14 14:11:45 / 修改时间：14:13:09" itemprop="dateCreated datePublished" datetime="2020-01-14T14:11:45+08:00">2020-01-14</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node-js/" itemprop="url" rel="index">
                    <span itemprop="name">Node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><a href="http://nodejs.cn/api/buffer.html" target="_blank" rel="noopener">Buffer</a></h1><p>JS自身只能只有字符串数据类型，没有二进制数据类型，因此nodejs提供了一个与string对等的全局构造函数Buffer来提供对二进制数据的操作</p>
<ul>
<li><p><code>Buffer.form</code> 创建一个buffer</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer.form([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]).toString()</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Burrer</code>与<code>String</code>的一个重要区别就是字符串时只读的，并且对于字符串的任何修改得到的都是一个新的字符串，源字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组，例如，可以使用<code>[index]</code>方式直接修改某个位置的字节</p>
</li>
</ul>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><a href="http://nodejs.cn/api/stream.html" target="_blank" rel="noopener">Stream</a></h1><ul>
<li><p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span> (<span class="params">src, dst</span>) </span>&#123;</span><br><span class="line">    fs.createReadStream(src).pipe(fs.createWriteSreeam(dst));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params">argv</span>) </span>&#123;</span><br><span class="line">    copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<a href="http://nodejs.cn/api/events.html#events_class_eventemitter" target="_blank" rel="noopener"><code>EventEmitter</code></a></p>
</li>
</ul>
<h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a><a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">File System</a></h1><p>NodeJS通过<code>fs</code>内置模块提供对文件的操作，<code>fs</code>模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>文件属性读<br>其中常见的有<code>fs.state</code> <code>fs.chmod</code> <code>fs.chown</code></li>
<li>文件属性写<br>其中常见的有<code>fs.readFile</code> <code>fs.readdir</code> <code>fs.writeFile</code> <code>fs.mkdir</code></li>
<li>底层文件操作<br>其中常见的操作有<code>fs.open</code> <code>fs.read</code> <code>fs.write</code> <code>fs.close</code><br>所有的<code>fs</code>模块API的回调参数都有两个，第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(pathname, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a><a href="http://nodejs.cn/api/path.html" target="_blank" rel="noopener">Path</a></h2><p>操作文件时难免不与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。</p>
<ul>
<li><p><code>path.normalize</code><br>  将传入的参数转为标准路径，具体讲的话，除了解析路径中的<code>.</code>与<code>..</code>外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cache[path.normalize(key)] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store(<span class="string">'foo/bar'</span>, <span class="number">1</span>);</span><br><span class="line">store(<span class="string">'foo//baz//../bar'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache);  <span class="comment">// =&gt; &#123; "foo/bar": 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>  标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径。</p>
</li>
<li><p><code>path.join</code><br>  将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'foo/'</span>, <span class="string">'baz/'</span>, <span class="string">'../bar'</span>); <span class="comment">// =&gt; "foo/bar"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>path.extname</code><br>  当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.extname(<span class="string">'foo/bar.js'</span>); <span class="comment">// =&gt; ".js"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span> (<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">    fs.readdirSync(dir).forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pathname = path.join(dir, file)</span><br><span class="line">        <span class="keyword">if</span> (fs.statSync(pathname).isDirectory())</span><br><span class="line">            travel(pathname, callback)</span><br><span class="line">        <span class="keyword">else</span> callback(pathname)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">travel(__dirname, file =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(file)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// c:\Users\mrrs8\Desktop\desktop.ini</span></span><br><span class="line"><span class="comment">// c:\Users\mrrs8\Desktop\Postman.lnk</span></span><br><span class="line"><span class="comment">// c:\Users\mrrs8\Desktop\test.js</span></span><br><span class="line"><span class="comment">// c:\Users\mrrs8\Desktop\微信开发者工具.lnk</span></span><br></pre></td></tr></table></figure>

<h1 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h1><p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有<code>UTF8</code>和<code>GBK</code>两种，并且<code>UTF8</code>文件还可能带有<code>BOM</code>。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的<code>UTF8</code>编码字符串后才能正常处理。</p>
<h2 id="BOM的移除"><a href="#BOM的移除" class="headerlink" title="BOM的移除"></a>BOM的移除</h2><p>BOM用于标记一个文本文件使用<code>Unicode</code>编码，其本身是一个<code>Unicode</code>字符<code>（&quot;\uFEFF&quot;）</code>，位于文本文件头部。在不同的<code>Unicode</code>编码下，<code>BOM</code>字符对应的二进制字节如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Bytes      Encoding</span><br><span class="line">----------------------------</span><br><span class="line">    FE FF       UTF16BE</span><br><span class="line">    FF FE       UTF16LE</span><br><span class="line">    EF BB BF    UTF8</span><br></pre></td></tr></table></figure>

<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含<code>BOM</code>，以及使用哪种<code>Unicode</code>编码。但是，<code>BOM</code>字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉<code>BOM</code>，在某些使用场景下就会有问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 识别和去除UTF8 BOM</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readText</span> (<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bin = fs.readFileSync(pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bin[<span class="number">0</span>] === <span class="number">0xEF</span> &amp;&amp; bin[<span class="number">1</span>] === <span class="number">0xBB</span> &amp;&amp; bin[<span class="number">2</span>] === <span class="number">0xBF</span>) &#123;</span><br><span class="line">        bin = bin.slice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bin.toString(<span class="string">'utf-8'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GBK转UTF8"><a href="#GBK转UTF8" class="headerlink" title="GBK转UTF8"></a>GBK转UTF8</h2><p>NodeJS支持在读取文本文件时，或者在<code>Buffer</code>转换为字符串时指定文本编码，但遗憾的是，<code>GBK</code>编码不在NodeJS自身支持范围内。因此，一般我们借助<code>iconv-lite</code>这个三方包来转换编码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GBK转UTF8</span></span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readGBKText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bin = fs.readFileSync(pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iconv.decode(bin, <span class="string">'gbk'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单字节编码"><a href="#单字节编码" class="headerlink" title="单字节编码"></a>单字节编码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = fs.readFileSync(pathname, <span class="string">'binary'</span>);</span><br><span class="line">    str = str.replace(<span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line">    fs.writeFileSync(pathname, str, <span class="string">'binary'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/01/14/go-gin-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/01/14/go-gin-基础/" class="post-title-link" itemprop="url">go-gin-基础</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-01-14 14:05:44" itemprop="dateCreated datePublished" datetime="2020-01-14T14:05:44+08:00">2020-01-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-06 17:42:49" itemprop="dateModified" datetime="2020-02-06T17:42:49+08:00">2020-02-06</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go-gin/" itemprop="url" rel="index">
                    <span itemprop="name">go gin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="获取GET-path参数"><a href="#获取GET-path参数" class="headerlink" title="获取GET path参数"></a>获取<code>GET</code> <code>path</code>参数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := gin.Default()</span><br><span class="line">  r.GET(<span class="string">"/index/:id"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span>&#123;</span><br><span class="line">    r.JOSN(http.StatusOK, gin.H&#123;</span><br><span class="line">      <span class="string">"id"</span>: context.Param(<span class="string">"id"</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取POST-raw-json参数"><a href="#获取POST-raw-json参数" class="headerlink" title="获取POST raw json参数"></a>获取<code>POST</code> <code>raw json</code>参数</h1><ol>
<li><p>定义一个公用<code>struct</code>，用于标准返回数据格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResBodyS <span class="keyword">struct</span> &#123;</span><br><span class="line">  ErrCode <span class="keyword">int</span> <span class="string">`json:"errCode"`</span></span><br><span class="line">  Desc <span class="keyword">string</span> <span class="string">`json:"description" binding:"required"`</span> <span class="comment">//参数存在性校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义针对于特定接口的<code>struct</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IndexReqBodyS <span class="keyword">struct</span> &#123;</span><br><span class="line">  ResBodyS</span><br><span class="line">  Data <span class="keyword">string</span> <span class="string">`json:"index"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>context.BindJSON()</code>解析请求中的body参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := gin,Default()</span><br><span class="line">  r.POST(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reqInfo IndexReqBodyS</span><br><span class="line">    err := context.BindJSON(&amp;reqInfo)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.PrintFln(<span class="string">"parse json data error! err:"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    context.JSON(http.StatusOK, reqInfo)</span><br><span class="line">  &#125;)</span><br><span class="line">  r.Run(<span class="string">":9090"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p>在 Go 中异常就是<code>panic</code>，它是在程序运行的时候抛出的，当<code>panic</code>抛出之后，如果在程序里没有添加任何保护措施的话，控制台就会在打印出<code>panic</code>的详细情况，然后终止运行。<br>当程序发生<code>panic</code>后，在<code>defer</code>(延迟函数) 内部可以调用<code>recover</code>进行捕获。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := <span class="built_in">recover</span>();</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmp.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>使用<code>net/http/httptest</code>包<br>与原生测试相比，使用<code>gin.Engine.ServeHTTP</code>发送请求(原生使用<code>http.HandlerFunc.ServeHTTP</code>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engine *gin.Engine</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> accessToken = <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODA5OTE1NTUsInVzZXJfaWQiOjE4LCJuYW1lIjoidGVzdDEifQ.900X9t3qveW0NGn3_FhYxHXlgsLAdl1BkjfKxNlBNyE"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateRequest</span><span class="params">(method constant.HttpRequestMethod, url <span class="keyword">string</span>, params <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(status constant.ResultCode, resBody *util.ResS, returnError error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine == <span class="literal">nil</span> &#123;</span><br><span class="line">		gin.SetMode(gin.ReleaseMode)</span><br><span class="line">		engine = gin.New()</span><br><span class="line">		database.SetUpDatabase()</span><br><span class="line">		controller.SetupRouter(engine)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		rr        = httptest.NewRecorder()</span><br><span class="line">		req       = <span class="built_in">new</span>(http.Request)</span><br><span class="line">		err error = <span class="literal">nil</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> params != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp, err := json.Encode(params)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> constant.FAILED, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		req, err = http.NewRequest(<span class="keyword">string</span>(method), url, bytes.NewBuffer([]<span class="keyword">byte</span>(tmp)))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		req, err = http.NewRequest(<span class="keyword">string</span>(method), url, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> constant.FAILED, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req.Header.Add(<span class="string">"Authorization"</span>, fmt.Sprintf(<span class="string">"Bear %s"</span>, accessToken))</span><br><span class="line">	engine.ServeHTTP(rr, req)</span><br><span class="line"></span><br><span class="line">	formatRes := util.ResS&#123;&#125;</span><br><span class="line">	err = json.Decode(rr.Body.Bytes(), &amp;formatRes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> constant.FAILED, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> constant.SUCCESS, &amp;formatRes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTest</span><span class="params">(t *testing.T, method constant.HttpRequestMethod, url <span class="keyword">string</span>, params <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	_, resBody, err := CreateRequest(method, url, params)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">"got error: %s"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resBody != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> resBody.Code != constant.SUCCESS &#123;</span><br><span class="line">			t.Errorf(<span class="string">"GetInfo test failed, got: %v, info: %s"</span>, resBody.Data, resBody.Message)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/01/14/go-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/01/14/go-基础/" class="post-title-link" itemprop="url">go-极速入门</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-01-14 13:43:45" itemprop="dateCreated datePublished" datetime="2020-01-14T13:43:45+08:00">2020-01-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-06 17:25:31" itemprop="dateModified" datetime="2020-02-06T17:25:31+08:00">2020-02-06</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="依赖包管理工具"><a href="#依赖包管理工具" class="headerlink" title="依赖包管理工具"></a>依赖包管理工具</h1><ul>
<li><p>dep<br>未完待续…</p>
</li>
<li><p>go vendor<br>未完待续…</p>
</li>
<li><p>glide<br>未完待续…</p>
</li>
<li><p><strong>go modules</strong></p>
<p>伴随Go 1.11出现，<strong>官方推荐</strong></p>
</li>
</ul>
<h1 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h1><ul>
<li><p><code>go mod tidy</code></p>
<p>拉取缺少的模块，移除不用的模块</p>
</li>
<li><p><code>go mod vandor</code></p>
<p>将依赖复制到vendor下</p>
</li>
<li><p><code>go mod download</code></p>
<p>下载依赖包</p>
</li>
<li><p><code>go mod verify</code></p>
<p>检测依赖</p>
</li>
<li><p><code>go mod graph</code></p>
<p>打印模块依赖图</p>
</li>
</ul>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="切片就像数组的引用"><a href="#切片就像数组的引用" class="headerlink" title="切片就像数组的引用"></a>切片就像数组的引用</h2><h2 id="切片拥有-长度-和-容量"><a href="#切片拥有-长度-和-容量" class="headerlink" title="切片拥有 长度 和 容量"></a>切片拥有 <em>长度</em> 和 <em>容量</em></h2><ul>
<li>切片的长度就是它所包含的元素个数。</li>
<li>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</li>
<li>切片 s 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</li>
</ul>
<h2 id="切片可以用内建函数-make-来创建，这也是创建动态数组的方式。make-函数会分配一个元素为零值的数组并返回一个引用了它的切片："><a href="#切片可以用内建函数-make-来创建，这也是创建动态数组的方式。make-函数会分配一个元素为零值的数组并返回一个引用了它的切片：" class="headerlink" title="切片可以用内建函数 make 来创建，这也是创建动态数组的方式。make 函数会分配一个元素为零值的数组并返回一个引用了它的切片："></a>切片可以用内建函数 <code>make</code> 来创建，这也是创建动态数组的方式。<code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要指定它的容量，需向 make 传入第三个参数：</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure>

<h2 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h2><p>append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。append 的结果是一个包含原切片所有元素加上新添加元素的切片。当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个(<strong>cap值翻倍</strong>)更大的数组。返回的切片会指向这个新分配的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    printSlice(s)</span><br><span class="line">    <span class="comment">// len=0 cap=0 []</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cap不够用——&gt;cap翻倍——&gt;cap=2</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line">    <span class="comment">// len=1 cap=2 [0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cap够用——&gt;保持不变——&gt;cap=2</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line">    <span class="comment">// len=2 cap=2 [0 1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cap不够用——&gt;cap翻倍——&gt;cap=8</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line">    <span class="comment">// len=5 cap=8 [0 1 2 3 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cap够用——&gt;cap保持不变——&gt;cap=8</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line">    <span class="comment">// len=8 cap=8 [0 1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"len=%d cap=%d %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map-无序的-key-value-数据结构"><a href="#map-无序的-key-value-数据结构" class="headerlink" title="map-无序的 key-value 数据结构"></a><code>map</code>-无序的 <code>key-value</code> 数据结构</h1><p>map集合中的 <code>key/value</code> 可以是任意类型，但所有<code>key</code>必须同属于一种数据类型，所有的<code>value</code>必须同属于一种数据类型。<code>key</code> 和 <code>value</code> 的数据类型可以不相同</p>
<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person := [<span class="number">3</span>]<span class="keyword">string</span> &#123; <span class="string">"tom"</span>, <span class="string">"john"</span>, <span class="string">"jerry"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> person &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"person[%d]: %s\n"</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="go关键字"><a href="#go关键字" class="headerlink" title="go关键字"></a><code>go</code>关键字</h1><p>在go关键字后面加一个函数，就可以创建一个线程，函数可以为已经写好的函数，也可以是匿名函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"main start"</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"goroutine"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  time.sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  fmt.Printf(<span class="string">"main end"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="chan-类似于队列，遵循先进先出的规则"><a href="#chan-类似于队列，遵循先进先出的规则" class="headerlink" title="chan-类似于队列，遵循先进先出的规则"></a><code>chan</code>-类似于队列，遵循先进先出的规则</h1><h2 id="声明chan"><a href="#声明chan" class="headerlink" title="声明chan"></a>声明<code>chan</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明不带缓冲的通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明带10个缓冲的通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明只读通道</span></span><br><span class="line">ch3 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明只写通道</span></span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>

<p>不带缓冲的通道，进何处都会阻塞<br>带缓冲的通道，进一次长度+1，出一次长度-1，如果长度等于缓冲区长度时，再进就会阻塞</p>
<h2 id="写入chan"><a href="#写入chan" class="headerlink" title="写入chan"></a>写入<code>chan</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">ch1 &lt;- <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h2 id="读取chan"><a href="#读取chan" class="headerlink" title="读取chan"></a>读取<code>chan</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val, ok := &lt;- ch1</span><br><span class="line">val := &lt;- ch1</span><br></pre></td></tr></table></figure>

<h2 id="关闭chan"><a href="#关闭chan" class="headerlink" title="关闭chan"></a>关闭<code>chan</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(<span class="keyword">chan</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productor</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"producer start"</span>)</span><br><span class="line">  ch &lt;- <span class="string">"a"</span></span><br><span class="line">  ch &lt;- <span class="string">"b"</span></span><br><span class="line">  ch &lt;- <span class="string">"c"</span></span><br><span class="line">  ch &lt;- <span class="string">"d"</span></span><br><span class="line">  fmt.Println(<span class="string">"producer end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"main start"</span>)</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">go</span> producer(ch)</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  fmt.Println(<span class="string">"main end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main start</span></span><br><span class="line"><span class="comment">// producer start  发生阻塞</span></span><br><span class="line"><span class="comment">// main end</span></span><br></pre></td></tr></table></figure>

<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a><code>defer</code></h1><p>主要应用场景有异常处理、记录日志、清理数据、释放资源 等等。</p>
<ul>
<li><code>defer</code>在声明时不会立刻去执行，而是在函数 <code>return</code> 后去执行的。</li>
<li><code>defer</code>函数定义的顺序与实际执行的顺序是相反的，也就是最先声明的最后才执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">"c"</span>)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">"d"</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="keyword">string</span>, a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ret := a + b</span><br><span class="line">	fmt.Println(index, a, b, ret)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">1</span></span><br><span class="line">	y := <span class="number">2</span></span><br><span class="line">	<span class="keyword">defer</span> calc(<span class="string">"A"</span>, x, calc(<span class="string">"B"</span>, x, y))</span><br><span class="line">	x = <span class="number">3</span></span><br><span class="line">	<span class="keyword">defer</span> calc(<span class="string">"C"</span>, x, calc(<span class="string">"D"</span>, x, y))</span><br><span class="line">	y = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 1 2 3</span></span><br><span class="line"><span class="comment">// D 3 2 5</span></span><br><span class="line"><span class="comment">// C 3 5 8</span></span><br><span class="line"><span class="comment">// A 1 3 4</span></span><br></pre></td></tr></table></figure>

<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a><code>interface</code></h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><ul>
<li>一种<strong>抽象</strong>类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sayer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sayer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat *Cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"miao miao miao~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog *Dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"wang wang wang~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dog Dog</span><br><span class="line">	dog.say()</span><br><span class="line">	<span class="keyword">var</span> cat Cat</span><br><span class="line">	cat.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h2><ul>
<li>空接口作为函数的参数</li>
<li>空接口作为<code>map</code>的值</li>
<li>类型断言<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	x = <span class="string">"hello world"</span></span><br><span class="line">	v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"类型断言失败"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的<code>Go</code>代码过程是类似的。</p>
<p><code>go test</code>命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>
<p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th align="left">格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>测试函数</td>
<td align="left">函数名前缀为<code>Test</code></td>
<td>测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td>基准函数</td>
<td align="left">函数名前缀为<code>Benchmark</code></td>
<td>测试函数的性能</td>
</tr>
<tr>
<td>示例函数</td>
<td align="left">函数名前缀为<code>Example</code></td>
<td>为文档提供示例文档</td>
</tr>
</tbody></table>
<p>测试函数实例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/imgs/avatar.png"
      alt="Mr.RS">
  <p class="site-author-name" itemprop="name">Mr.RS</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.RS</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>
