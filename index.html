<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png?v=7.4.1">
  <link rel="mask-icon" href="/images/avatar.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Mr.RS">
<meta property="og:url" content="https://mrrs878.github.io/index.html">
<meta property="og:site_name" content="Mr.RS">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.RS">
  <link rel="canonical" href="https://mrrs878.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Mr.RS</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.RS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Read The Fucking Source Code!</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      
    
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/04/13/webpack学习-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/04/13/webpack学习-1/" class="post-title-link" itemprop="url">webpack相关-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-13 23:19:33 / 修改时间：23:30:38" itemprop="dateCreated datePublished" datetime="2020-04-13T23:19:33+08:00">2020-04-13</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h1><h2 id="解析规则"><a href="#解析规则" class="headerlink" title="解析规则"></a>解析规则</h2><ul>
<li>解析相对路径<ol>
<li>查找相对当前模块的路径下是否有对应文件或文件夹</li>
<li>是文件则直接加载</li>
<li>是文件夹则继续查找文件夹下的 <code>package.json</code> 文件</li>
<li>有 package.json 文件则按照文件中 <code>main</code> 字段的文件名来查找文件</li>
<li>无 package.json 或者无 <code>main</code> 字段则查找 <code>index.js</code> 文件</li>
</ol>
</li>
<li>解析模块名<br>查找当前文件目录下，父级目录及以上目录下的 <code>node_modules</code> 文件夹，看是否有对应名称的模块</li>
<li>解析绝对路径（不建议使用）<br>直接查找对应路径的文件</li>
</ul>
<p>在 webpack 配置中，和模块路径解析相关的配置都在 <code>resolve</code> 字段下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><ul>
<li><p><code>resolve.alias</code>， 配置别名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            utils$: path.resolve(__dirname, <span class="string">'src/utils'</span>) <span class="comment">// 只会匹配 import 'utils'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>resolve.extensions</code>，文件扩展名简写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: &#123;</span><br><span class="line">            extensions: [<span class="string">'.wasm'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>resolve.modules</code>，配置直接声明依赖名的模块的解析路径</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      modules: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'node_modules'</span>), <span class="comment">// 指定当前目录下的 node_modules 优先查找</span></span><br><span class="line">        <span class="string">'node_modules'</span>, <span class="comment">// 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录</span></span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>resolve.mainFields</code>，有<code>package.json</code>文件入口文件的配置</p>
</li>
<li><p><code>resolve.mainFiles</code>，没有<code>package.json</code>文件时入口文件的配置</p>
</li>
</ul>
<h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p>webpack 的 <code>loader</code> 相关配置都在 <code>module.rules</code> 字段下，我们需要通过 <code>test</code>、<code>include</code>、<code>exclude</code> 等配置好应用 <code>loader</code> 的条件规则，然后使用 <code>use</code> 来指定需要用到的 <code>loader</code>，配置应用的 <code>loader</code> 时还需要注意一下 <code>loader</code> 的执行顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="comment">//,</span></span><br><span class="line">                include: [],</span><br><span class="line">        		use: xxx</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="规则条件配置"><a href="#规则条件配置" class="headerlink" title="规则条件配置"></a>规则条件配置</h2><ul>
<li><code>{ test: ... }</code> 匹配特定条件</li>
<li><code>{ include: ... }</code> 匹配特定路径</li>
<li><code>{ exclude: ... }</code> 排除特定路径</li>
<li><code>{ and: [...] }</code>必须匹配数组中所有条件</li>
<li><code>{ or: [...] }</code> 匹配数组中任意一个条件</li>
<li><code>{ not: [...] }</code> 排除匹配数组中所有条件</li>
</ul>
<h2 id="module-type"><a href="#module-type" class="headerlink" title="module type"></a>module type</h2><h2 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h2><h2 id="loader加载顺序"><a href="#loader加载顺序" class="headerlink" title="loader加载顺序"></a>loader加载顺序</h2><h2 id="使用noParse"><a href="#使用noParse" class="headerlink" title="使用noParse"></a>使用noParse</h2>
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/04/09/浏览器相关-跨域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/04/09/浏览器相关-跨域/" class="post-title-link" itemprop="url">浏览器相关-跨域</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-09 23:26:29" itemprop="dateCreated datePublished" datetime="2020-04-09T23:26:29+08:00">2020-04-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-11 20:44:03" itemprop="dateModified" datetime="2020-04-11T20:44:03+08:00">2020-04-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浏览器/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="WHAT-什么是跨域及同源策略"><a href="#WHAT-什么是跨域及同源策略" class="headerlink" title="WHAT-什么是跨域及同源策略"></a>WHAT-什么是跨域及同源策略</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/源" target="_blank" rel="noopener">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol" target="_blank" rel="noopener">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/port" target="_blank" rel="noopener">port</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/en-US/docs/Glossary/host" target="_blank" rel="noopener">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p>
<p><strong>同源策略限制内容有：</strong></p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求发送后，结果被浏览器拦截了</li>
</ul>
<p>但是有三个标签是允许跨域加载资源：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code></li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源就算做<strong>跨域</strong>。</p>
<p>特别说明：</p>
<ol>
<li><p>如果是协议和端口造成的跨域问题，前端是无能为力的</p>
</li>
<li><p>在跨域问题上，仅仅是通过<strong>URL的首部</strong>来识别而不会根据域名对应的ip是否相同来判断。</p>
</li>
<li><p>请求跨域后，请求到底有没有发送出去：</p>
<p>跨域不是请求发送不出去，请求能发送出去，服务端能接收到请求并正常的返回，只是结果被浏览器拦截了（同源策略）。</p>
</li>
<li><p>为什么通过表单的方式可以发起跨域请求，Ajax就不能？</p>
<p>归根结底，跨域是因为了阻止用户读取到另一个域名下的内容，Ajax可以获取响应，浏览器任务这不安全所以拦截了响应；但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>
</li>
</ol>
<h1 id="WHY-为什么有同源策略"><a href="#WHY-为什么有同源策略" class="headerlink" title="WHY-为什么有同源策略"></a>WHY-为什么有同源策略</h1><p><strong>安全</strong></p>
<h1 id="HOW-跨域解决方案"><a href="#HOW-跨域解决方案" class="headerlink" title="HOW-跨域解决方案"></a>HOW-跨域解决方案</h1><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>原理：利用<code>&lt;script&gt;</code>标签没有同源策略限制的漏洞，网页可以得到从其他源动态产生的JSON数据。JSONP请求一定需要对方的<strong>服务器支持</strong>。JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是<strong>仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">        <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="built_in">document</span>.body.removeChildren(script)</span><br><span class="line">        &#125;</span><br><span class="line">        params = &#123; ...params, callback &#125;</span><br><span class="line">        <span class="keyword">let</span> arrs = []</span><br><span class="line">        <span class="built_in">Object</span>.keys(params).forEach(<span class="function"><span class="params">item</span> =&gt;</span> arrs.push(<span class="string">`<span class="subst">$&#123; key &#125;</span>=<span class="subst">$&#123; params[key] &#125;</span>`</span>))</span><br><span class="line">        script.src = <span class="string">`<span class="subst">$&#123; url &#125;</span>?<span class="subst">$&#123; arrs.join(<span class="string">'&amp;'</span>) &#125;</span>`</span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS需要<strong>浏览器和后端同时支持</strong></p>
<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>只要<strong>同时满足</strong>以下条件，就属于简单请求：</p>
<ol>
<li>method=GET/POST/HEAD</li>
<li>Content-Type=text/plain或multipart/form-data或application/x-www-form-urlencoded</li>
<li>请求中的任意<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器；<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload" target="_blank" rel="noopener"><code>XMLHttpRequest.upload</code></a> 属性访问</li>
</ol>
<h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3><p> 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为<strong>预检请求</strong>,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>Websocket是HTML5的一个持久化协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/04/08/浏览器相关-安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/04/08/浏览器相关-安全/" class="post-title-link" itemprop="url">浏览器相关-安全</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-08 23:15:51 / 修改时间：23:17:35" itemprop="dateCreated datePublished" datetime="2020-04-08T23:15:51+08:00">2020-04-08</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浏览器/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS(cross-site scripting)，跨站脚本攻击（缩写和CSS重叠，所以称之为XSS）。XSS指的是通过存在安全漏洞的web网站注册用户的<strong>浏览器</strong>内<strong>自动运行非法的HTML标签或JavaScript</strong>进行的一种攻击</p>
<p>如果 Web 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取 cookie，session tokens，或者其它敏感的网站信息，或者让恶意脚本重写<a href="https://developer.mozilla.org/en-US/docs/Glossary/HTML" target="_blank" rel="noopener">HTML</a>内容。</p>
<p>XSS可能会造成以下影响：</p>
<ul>
<li>利用虚假表单骗取用户个人信息</li>
<li>利用脚本窃取用户的cookie值，被害者在不知情的情况下帮助攻击者发送恶意请求</li>
<li>显示伪造的文章或图片</li>
</ul>
<h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>注入型脚本永久<strong>存储在目标服务器上</strong>。当浏览器请求数据时，脚本从服务器上传回并执行。</p>
<h3 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h3><p>当<strong>用户点击</strong>一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。</p>
<h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><ul>
<li><p>CSP</p>
<p>建立白名单，明确告诉浏览器那些外部资源可以进行加载和执行。</p>
<ol>
<li><p>设置<code>HTTP Header</code>中的<code>Content-Security-Policy</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--- 只允许加载本站资源 ---&gt;</span></span><br><span class="line">Content-Security-Policy: default-src 'self'</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只允许加载HTTPS图片 --&gt;</span></span><br><span class="line">Content-Security-Policy: img-src https://*</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>meta</code>标签</p>
</li>
</ol>
</li>
<li><p>转义字符</p>
<p>对引号、尖括号、斜杠进行转义</p>
</li>
<li><p>httponly cookie</p>
<p>这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息</p>
</li>
</ul>
<h3 id="基于DOM的XSS"><a href="#基于DOM的XSS" class="headerlink" title="基于DOM的XSS"></a>基于DOM的XSS</h3><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/24/1688030a24702301?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="CSRF原理"></p>
<h3 id="如何防御-1"><a href="#如何防御-1" class="headerlink" title="如何防御"></a>如何防御</h3><p>防范 CSRF 攻击可以遵循以下几种规则：</p>
<ul>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie</li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 Token</li>
</ul>
<ol>
<li><p>samesite</p>
<p>可以对 Cookie 设置 SameSite 属性。该属性表示 <strong>Cookie 不随着跨域请求发送</strong>，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>
</li>
<li><p>referer check</p>
<p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以<strong>通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击</strong>。</p>
<p>但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。</p>
</li>
<li><p>anti CSRF token</p>
<p>目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>
<p><strong>这种方法相比Referer检查要安全很多</strong>，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。</p>
</li>
<li><p>验证码</p>
<p>在关键业务点设置验证码</p>
</li>
</ol>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <strong>iframe</strong> 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<h3 id="如何防御-2"><a href="#如何防御-2" class="headerlink" title="如何防御"></a>如何防御</h3><ul>
<li><p>X-FRAME-OPTIONS</p>
<p><code>X-FRAME-OPTIONS</code>是一个 HTTP 响应头，三个值可选，分别是</p>
<ul>
<li>DENY，表示页面不允许通过 iframe 的方式展示</li>
<li>SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示</li>
<li>ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示</li>
</ul>
</li>
</ul>
<h2 id="URL跳转漏洞"><a href="#URL跳转漏洞" class="headerlink" title="URL跳转漏洞"></a>URL跳转漏洞</h2><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>
<p>SQL注入必备条件：</p>
<ol>
<li>可以控制输入的数据</li>
<li>服务器要执行的代码拼接了控制的数据</li>
</ol>
<h3 id="如何防御-3"><a href="#如何防御-3" class="headerlink" title="如何防御"></a>如何防御</h3><ul>
<li><p><strong>严格限制Web应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>
</li>
<li><p><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>
</li>
<li><p><strong>对进入数据库的特殊字符（’，”，\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换</strong>。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。</p>
</li>
<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/04/02/浏览器相关-存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/04/02/浏览器相关-存储/" class="post-title-link" itemprop="url">浏览器相关-存储</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-02 22:49:39" itemprop="dateCreated datePublished" datetime="2020-04-02T22:49:39+08:00">2020-04-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 23:18:46" itemprop="dateModified" datetime="2020-04-08T23:18:46+08:00">2020-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浏览器/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于存储的问题都会涉及到三个问题:</p>
<ol>
<li>存储场所</li>
<li>存储空间</li>
<li>存储时间</li>
</ol>
<p>(在哪儿存储，多少数据，到什么时候)这些特性决定了不同方案的用途</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li><p>WHAT</p>
<p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699f22b7029ca14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cookie的原理"></p>
</li>
<li><p>WHY</p>
<p>cookie的本职工作并非进行本地存储，而是<strong>维持状态</strong>。因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了<strong>交互式Web程序</strong>的实现，于是就诞生了cookie。他就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取cookie中包含信息，借此维护用户跟服务器会话的状态</p>
<p>cookie的缺陷：</p>
<ul>
<li>cookie不够大，各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</li>
<li>过多的 Cookie 会带来巨大的性能浪费，每次请求都会携带cookie</li>
<li>安全性较差，由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS</li>
</ul>
</li>
<li><p>HOW</p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<p>cookie的生成方式主要有两种：</p>
<ol>
<li><p><code>http response header</code>中的<code>set-cookie</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2019</span> <span class="number">22</span>:<span class="number">28</span>:<span class="number">00</span> GMT;<span class="comment">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>js中通过<code>document.cookie</code>可以读写cookie，以键值对的形式展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"userName=mrrs878"</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"age=23"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>常用后缀及其含义：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>如果用于保存用户登录态，应该将值加密，不能使用明文的用户标识</td>
</tr>
<tr>
<td>http-only</td>
<td>不能通过JS访问cookie，减少XSS攻击</td>
</tr>
<tr>
<td>secure</td>
<td>只能在协议为HTTPS的请求中携带</td>
</tr>
<tr>
<td>same-site</td>
<td>规定浏览器不能再跨域请求中携带cookie，减少CSRF攻击</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。<strong>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage</strong>。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>特点：</p>
<ul>
<li>持久化存储</li>
<li>数据大小限制提升到5M</li>
<li>仅在客户端使用，不与服务器通信</li>
</ul>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line">localStorage.setItem(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">localStorage.getItem(<span class="string">"key"</span>)；</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>存储一些稳定的资源，如图片转为base64存储在本地加快访问</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>特点：</p>
<ul>
<li>会话级别的存储（包括父页面生成的新标签页）</li>
<li>数据大小限制提升到5M</li>
<li>仅在客户端使用，不与服务器通信</li>
</ul>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>)</span><br><span class="line">sessionStorage.getItem(<span class="string">'key'</span>, <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>对表单信息进行维护，比如刷新时，表单信息不丢失</p>
<h2 id="cookie、localstorage、sessionstorage的区别"><a href="#cookie、localstorage、sessionstorage的区别" class="headerlink" title="cookie、localstorage、sessionstorage的区别"></a>cookie、localstorage、sessionstorage的区别</h2><table>
<thead>
<tr>
<th></th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>由谁初始化</td>
<td>客户端或服务器，服务器可以使用Set-Cookie请求头</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>存储位置</td>
<td>客户端</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>过期时间</td>
<td>手动设置</td>
<td>无</td>
<td>当前会话</td>
</tr>
<tr>
<td>在当前会话中保持不变</td>
<td>取决过期时间</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否随着请求发送给服务器</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>容量</td>
<td>4Kb(单个name)</td>
<td>5Mb(单个域名)</td>
<td>5Mb(单个域名)</td>
</tr>
<tr>
<td>访问权限</td>
<td>任意窗口</td>
<td>任意窗口</td>
<td>当前窗口</td>
</tr>
</tbody></table>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是一种低级API，<strong>用于客户端存储大量结构化数据(包括文件和blobs)</strong>。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。</p>
<p>特点：</p>
<ul>
<li>键值对储存</li>
<li>异步</li>
<li>事务</li>
<li>同源限制</li>
<li>支持二进制存储</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/04/01/HTML相关-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/04/01/HTML相关-0/" class="post-title-link" itemprop="url">HTML相关问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-01 23:00:40 / 修改时间：23:01:55" itemprop="dateCreated datePublished" datetime="2020-04-01T23:00:40+08:00">2020-04-01</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cookie、sessionStorage、localStorage的区别"><a href="#cookie、sessionStorage、localStorage的区别" class="headerlink" title="cookie、sessionStorage、localStorage的区别"></a>cookie、sessionStorage、localStorage的区别</h2><table>
<thead>
<tr>
<th></th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>由谁初始化</td>
<td>客户端或服务器，服务器可以使用Set-Cookie请求头</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>存储位置</td>
<td>客户端</td>
<td>客户端</td>
<td>客户端</td>
</tr>
<tr>
<td>过期时间</td>
<td>手动设置</td>
<td>无</td>
<td>当前会话</td>
</tr>
<tr>
<td>在当前会话中保持不变</td>
<td>取决过期时间</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否随着请求发送给服务器</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>容量（每个域名）</td>
<td>4Kb</td>
<td>5MB</td>
<td>5MB</td>
</tr>
<tr>
<td>访问权限</td>
<td>任意窗口</td>
<td>任意窗口</td>
<td>当前窗口</td>
</tr>
</tbody></table>
<h2 id="lt-script-gt-、-lt-script-async-gt-、-lt-script-defer-gt-区别"><a href="#lt-script-gt-、-lt-script-async-gt-、-lt-script-defer-gt-区别" class="headerlink" title="&lt;script&gt; 、&lt;script async&gt;、 &lt;script defer&gt; 区别"></a><code>&lt;script&gt;</code> 、<code>&lt;script async&gt;</code>、 <code>&lt;script defer&gt;</code> 区别</h2><p>当遇到这些标签时，会发生以下几种情况：</p>
<ul>
<li><code>script</code>，HTML解析中断，脚本被提取并立即执行，执行结束后，<code>HTML</code>解析继续</li>
<li><code>script async</code>，脚本的提取、执行的过程与<code>HTML</code>解析过程并行，脚本执行完毕可能在<code>HTML</code>解析完毕前。当脚本与页面上其他脚本独立时，可以使用<code>async</code>来加快页面渲染（比如用作页面统计分析）</li>
<li><code>script defer</code>，脚本的提取过程与<code>HTML</code>解析过程并行，脚本的执行将在<code>HTML</code>解析完毕后进行。如果有多个含<code>defer</code>的脚本，脚本的执行顺序按照在<code>document</code>中出现的位置，从上到下顺序执行。</li>
</ul>
<p>👀：没有<code>src</code>的脚本，<code>async</code>和<code>defer</code>属性会被忽略</p>
<h2 id="lt-link-gt-与-lt-script-gt-的放置位置"><a href="#lt-link-gt-与-lt-script-gt-的放置位置" class="headerlink" title="&lt;link&gt;与&lt;script&gt;的放置位置"></a><code>&lt;link&gt;</code>与<code>&lt;script&gt;</code>的放置位置</h2><ul>
<li><p>把<code>&lt;link&gt;</code>放在<code>&lt;head&gt;</code>中</p>
<p>把<code>link</code>标签放在<code>&lt;head&gt;&lt;/head&gt;</code>之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。</p>
</li>
<li><p>把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>底部</p>
<p>脚本在下载和执行期间会阻止 HTML 解析。把``标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。</p>
<p>在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，<code>&lt;</code>script<code>&gt;</code>使用<code>defer</code>属性，放在<code>&lt;head&gt;</code>中。</p>
</li>
</ul>
<h2 id="lt-img-gt-的title和alt属性"><a href="#lt-img-gt-的title和alt属性" class="headerlink" title="&lt;img&gt;的title和alt属性"></a><code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>属性</h2><ul>
<li><p><code>alt</code></p>
<p><code>alt</code>属性包含一条对图像的文本描述，这不是强制性的，但对可访问性而言，它<strong>难以置信地有用</strong>——屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示<code>alt</code> 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。</p>
</li>
<li><p><code>title</code></p>
<p><code>title</code> 属性不是 <code>alt</code> 属性可接受的替代品。并且，避免将 <code>alt</code> 属性的值直接复制到同一幅图片的<code>title</code> 属性上。这样可能会让一些屏幕阅读器把同一段描述读两遍，造成一定程度上的困扰。</p>
<p><code>title</code> 属性也不该被用作一幅图片在 <code>alt</code> 之外的补充说明信息。如果一幅图片需要小标题，使用 <code>figure</code> 或 <code>figcaption</code> 元素。</p>
<p><code>title</code>元素的值一般作为提示条(<code>tooltip</code>)呈现给用户，在光标于图片上停下后显示出来。尽管这<em>确实</em>能给用户提供更多的信息，您不该假定用户真的能看到：用户可能只有键盘或触摸屏。如果要把特别重要的信息提供给用户，选择上面提供的一种方法将其内联显示，而不是使用 <code>title</code></p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/24/CSS相关-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/24/CSS相关-0/" class="post-title-link" itemprop="url">CSS-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-24 23:29:35 / 修改时间：23:30:19" itemprop="dateCreated datePublished" datetime="2020-03-24T23:29:35+08:00">2020-03-24</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index">
                    <span itemprop="name">CSS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作为一个矩形盒子，这个盒子包含元素的内容、内边距、边框、外边距。</p>
<p>盒模型分为两种：</p>
<ul>
<li><p>标准盒模型（box-sizing = content-box）</p>
<p>width = content-width</p>
<p>height = content-height</p>
</li>
<li><p>IE盒模型（box-sizing = border-box）</p>
<p>width = content-width + padding + border</p>
<p>height = content-height + padding + border</p>
</li>
</ul>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>层叠上下文是<strong>包含一组图层的元素</strong>。 在一组层叠上下文中，其子元素的<strong>z-index值是相对于该父元素</strong>而不是 <code>document root</code> 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的<code>z-index</code>值，元素 C 也永远不会在元素 B 之上.</p>
<p>CSS 中的<code>z-index</code>属性控制重叠元素的垂直叠加顺序。<code>z-index</code>只能影响<code>position</code>值不是<code>static</code>的元素。</p>
<p>产生层叠上下文：</p>
<ol>
<li><p>HTML中的根元素<code>&lt;html&gt;&lt;/html&gt;</code>本身就具有层叠上下文，称为<strong>根层叠上下文</strong>。</p>
</li>
<li><p>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</p>
</li>
<li><p>CSS3中的新属性也可以产生层叠上下文。</p>
</li>
<li><ul>
<li>父元素的display属性值为<code>flex|inline-flex</code>，子元素<code>z-index</code>属性值不为<code>auto</code>的时候，子元素为层叠上下文元素；</li>
<li>元素的<code>opacity</code>属性值不是1；</li>
<li>元素的<code>transform</code>属性值不是<code>none</code>；</li>
<li>元素<code>mix-blend-mode</code>属性值不是normal；</li>
<li>元素的<code>filter</code>属性值不是<code>none</code>；</li>
</ul>
</li>
</ol>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/z-index.png" alt="z-index"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/12/webpack学习-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/12/webpack学习-0/" class="post-title-link" itemprop="url">webpack学习-0</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-12 23:51:35" itemprop="dateCreated datePublished" datetime="2020-03-12T23:51:35+08:00">2020-03-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-13 23:20:33" itemprop="dateModified" datetime="2020-04-13T23:20:33+08:00">2020-04-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><code>webpack</code>是一个现代的<code>JavaScript</code>应用程序打包工具。当<code>webpack</code>处理应用程序时，会递归构建一个<strong>依赖关系图</strong>，其中包含应用程序需要的每个模块，然后将这个模块打包成一个或多个bundle</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack-0.png" alt="概念图"></p>
<h2 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h2><ul>
<li><p><code>entry</code>（入口）</p>
<p>入口指示<code>webpack</code>应该使用哪个模块来作为构建其内部<strong>依赖图</strong>的开始。进入入口起点后，<code>webpack</code>会找出有哪些模块是库入口起点（直接和间接）依赖的</p>
<p>每个依赖项随即被处理，最后输出到称之为<code>bundles</code>的文件中。</p>
<p>可以通过在<code>webpack</code>配置中配置entry属性来指定一个或多个入口起点。默认为<code>./src</code></p>
</li>
<li><p><code>output</code>（出口）</p>
<p><code>output</code>告诉<code>webpack</code>在哪输出它所创建的<code>bundles</code>，以及如何命名这些文件，默认值为<code>./dist</code>。基本上，整个应用程序结构都会被编译到指定的输出路径的文件夹中。可以通过配置文件中的<code>output</code>字段来指定输出的文件夹</p>
</li>
<li><p><code>loader</code></p>
<p><code>loader</code>让<code>webpack</code>能够去处理那些非<code>JavaScript</code>文件（<code>webpack</code>自身只理解<code>JavaScript</code>）。<code>loader</code>能够将所有类型的文件转换为<code>webpack</code>能够处理的有效模块，然后就可以利用<code>webpack</code>的打包能力对它们进行处理。</p>
<p>同一个<code>rule</code>下的多个<code>loader</code>时将从右往左执行</p>
</li>
<li><p><code>plugin</code></p>
<p><code>loader</code>被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括从打包优化和压缩一直到重新定义环境中的变量，插件接口功能极其强大，可以用来处理各种各样的任务。</p>
<p>想要使用一个插件，只需要<code>require</code>它，然后把它添加到<code>plugins</code>配置项中。多数插件可以通过选项自定义。</p>
</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>webpack</code>的相关配置主要由根目录下的<code>webpack.config.js</code>来完成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    entry: [<span class="string">''</span>]</span><br><span class="line">    output: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    	rules: [&#123;&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">    plugins: [&#123;&#125;],</span><br><span class="line">    devServer: &#123;&#125;,</span><br><span class="line">    devtool: <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理JavaScript-babel-loader"><a href="#处理JavaScript-babel-loader" class="headerlink" title="处理JavaScript:babel-loader"></a>处理JavaScript:babel-loader</h2><p><code>webpack</code>本身可以识别<code>JavaScript</code>，但为了兼容老的浏览器，需要将<code>ES6</code>转换为向后兼容版本的<code>JavaScript</code>代码，<a href="https://babel.docschina.org/" target="_blank" rel="noopener">Babel</a>就是这么一种工具链。</p>
<p>当<code>webpack</code>打包源代码时，可能会很难追踪到错误和警告在源代码中的起始位置。为了<strong>更容易追踪错误和警告</strong>，<code>JavaScript</code>提供了<a href="http://blog.teamtreehouse.com/introduction-source-maps" target="_blank" rel="noopener">source map</a>功能，将编译后的代码映射回原始代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">            use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 开启source-map</span></span><br><span class="line">    devtool: <span class="string">'cheap-module-eval-source-map'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">api</span>) </span>&#123;</span><br><span class="line">    api.cache(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> presets = [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">    <span class="keyword">const</span> plugins = [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                corejs: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        presets,</span><br><span class="line">        plugins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理HTML"><a href="#处理HTML" class="headerlink" title="处理HTML"></a>处理HTML</h2><p>有时为了清除缓存，打包文件时会带有hash，那么每次生成的文件名会有所不同。如果在<code>html</code>中引用了这些文件，则需要更改引入的文件名，手工改动不可取。我们可以使用<code>html-webpack-plugin</code>来帮助处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">// template指定生成html的模板文件</span></span><br><span class="line">            template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">            <span class="comment">// 默认生成在./dist/index.html</span></span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">false</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理-ss"><a href="#处理-ss" class="headerlink" title="处理*ss"></a>处理*ss</h2><ul>
<li><code>style-loader</code>，动态创建<code>style</code>标签，将<code>css</code>插入到<code>head</code>中</li>
<li><code>css-loader</code>，负责处理<code>@import</code>等语句</li>
<li><code>postcss-loader</code>和<code>autoprefixer</code>，自动生成浏览器兼容性前缀</li>
<li><code>less-loader</code>，负责编译<code>.less</code>文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            plugins: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> [</span><br><span class="line">                                    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                                        <span class="string">'overrideBrowserslist'</span>: [</span><br><span class="line">                                            <span class="string">"&gt;0.25%"</span>,</span><br><span class="line">                                            <span class="string">'not dead'</span></span><br><span class="line">                                        ]</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">'less-loader'</span></span><br><span class="line">                ],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理本地资源文件"><a href="#处理本地资源文件" class="headerlink" title="处理本地资源文件"></a>处理本地资源文件</h2><p>可以使用url-loader或file-loader来处理本地的资源文件。url-loader和file-loader功能类似，但是url-loader可以指定文件在小于某一特定值下返回DataURL，可以减少http请求，推荐使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|gif|jpeg|svg|ttf)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: <span class="number">10240</span>,</span><br><span class="line">                            esModule: <span class="literal">false</span>,</span><br><span class="line">                            name: <span class="string">'assets/[name]_[hash:6].[ext]'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，对于html中的图片，url-loader则无能为力，此时需要<code>html-withimg-loader</code>来协助</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.html/</span>,</span><br><span class="line">                use: [<span class="string">'html-withimg-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/10/vuex剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/10/vuex剖析/" class="post-title-link" itemprop="url">vuex剖析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-10 20:50:56 / 修改时间：23:12:33" itemprop="dateCreated datePublished" datetime="2020-03-10T20:50:56+08:00">2020-03-10</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>vuex是专门为Vue.js设计的<strong>状态管理工具</strong>，它采用<strong>集中式存储</strong>管理应用的所有状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h2 id="vuex的构成"><a href="#vuex的构成" class="headerlink" title="vuex的构成"></a>vuex的构成</h2><ul>
<li><p>引入<code>State</code>、<code>Getter</code>对状态进行定义</p>
</li>
<li><p>使用<code>Mutation</code>、<code>Action</code>对状态进行修改</p>
</li>
<li><p>使用<code>Module</code>对状态进行模块化分割</p>
</li>
<li><p>引入插件对状态进行快照、记录、跟踪等</p>
</li>
<li><p>提供<code>mapState</code>、<code>mapGetters</code>、<code>mapActions</code>、<code>mapMutations</code>辅助函数方便开发者处理store</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-0.png" alt="vuex组成"></p>
</li>
</ul>
<h2 id="vuex原理"><a href="#vuex原理" class="headerlink" title="vuex原理"></a>vuex原理</h2><h3 id="vuex的store是如何注入到组件中的"><a href="#vuex的store是如何注入到组件中的" class="headerlink" title="vuex的store是如何注入到组件中的"></a>vuex的store是如何注入到组件中的</h3><ul>
<li><p>通过vue的<a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener">mixin</a>机制，在<code>install</code>函数中借助于vue的<code>beforeCreate</code>生命周期函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>beforeCreate</code>中调用vuexInit将store挂载到当前实例上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="comment">// store injection</span></span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">        <span class="comment">// 根组件通过options.store挂载</span></span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">typeof</span> options.store === <span class="string">'function'</span></span><br><span class="line">            ? options.store()</span><br><span class="line">        	: options.store</span><br><span class="line">        <span class="comment">// 其余组件通过父组件上的store挂载</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store = options.parent.$store</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-1.jpg" alt="store注入"></p>
</li>
</ul>
<h3 id="vuex的state和getter是如何映射到各个组件实例中自动更新的"><a href="#vuex的state和getter是如何映射到各个组件实例中自动更新的" class="headerlink" title="vuex的state和getter是如何映射到各个组件实例中自动更新的"></a>vuex的state和getter是如何映射到各个组件实例中自动更新的</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    construcor () &#123;</span><br><span class="line">        resetStoreVM()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> state () &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   	store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       	data: &#123;</span><br><span class="line">       		$$state: state</span><br><span class="line">       	&#125;,</span><br><span class="line">      	computed</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码得知，当使用<code>this.$store.state.xxx</code>时会被代理到<code>store._vm._data.$$state</code>上，而<code>store._vm</code>是一个Vue实例，由于示例中的data是响应式的，所以$$state也是响应式的，那么当更新state时，所有相关组件中的state也会自动更新</p>
<h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    	<span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    	<span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">    	<span class="comment">// using partial to return function with only arguments preserved in closure environment.</span></span><br><span class="line">        computed[key] = partial(fn, store)</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">            <span class="keyword">get</span>: () =&gt; store._vm[key],</span><br><span class="line">            enumerable: true // for local getters</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码得知，当使用<code>this.$store.getter.xxx</code>时会被代理到<code>store._vm.xxx</code>，其中添加<code>computed</code>属性</p>
<p>从上面可以看出，Vuex中的<code>state</code>是借助于一个Vue.js实例，将state存入示例中的<code>data</code>中；Vuex中的<code>getter</code>则是借助于实例的计算属性<code>computed</code>实现数据监听</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-3.png" alt="state、getter响应式"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/09/vue-router剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/09/vue-router剖析/" class="post-title-link" itemprop="url">vue-router剖析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-09 22:05:40 / 修改时间：23:30:51" itemprop="dateCreated datePublished" datetime="2020-03-09T22:05:40+08:00">2020-03-09</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由最早由后端提出，用于根据不同的请求返回不同的页面。大致流程如下：</p>
<ol>
<li>浏览器发出请求</li>
<li>服务器监听到端口有请求过来</li>
<li>根据服务器的路由配置，返回相应信息（可以是html、json、图片等）</li>
<li>浏览器根据数据包的<code>Context-Type</code>来决定如何解析</li>
</ol>
<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><p>随着<code>ajax</code>的流行，异步数据请求交互在不刷新浏览器的情况下运行。而异步交互体验的高级版本就是SPA-单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。类似于后端路由，前端路由就是匹配不同的url路径进行解析，然后动态渲染html内容。</p>
<h3 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h3><p><code>https://www.xxx.com/#/hash</code></p>
<p>这种<code>#</code>后面<code>hash</code>值得变化，并不会触发新的请求，因此也不会刷新页面。每次<code>hash</code>值的变化都会触发<code>hashchange</code>事件，通过这个事件就可以知道更新哪些页面内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.oldURL, e.newURL)</span><br><span class="line">    <span class="keyword">const</span> hash = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">    app.innerHTML = hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h3><p><code>https://www.xxx.com/login</code></p>
<p>随着HTML5的发布，带来了两个新的API：<code>pushState</code>和<code>replaceState</code>，通过这两个API可以改变url地址且不会发送请求。同时还有<code>popstate</code>事件用来监听url的改变。使用history模式，url就不会出现丑陋的<code>#</code>，url也变得比较美观。</p>
<p>通过history api去掉了丑陋的<code>#</code>，但也存在问题：不怕前进/后退，就怕<strong>刷新</strong>。因为刷新是去请求服务器的，在<code>hash</code>下，前端路由修改的是#之后的内容，在发送请求时是不会带上的，但在history下可以自由地修改路径、参数，当刷新时，如果服务器中没有相应的响应或资源，容易爆<code>404</code></p>
<h2 id="vue-router核心原理"><a href="#vue-router核心原理" class="headerlink" title="vue-router核心原理"></a>vue-router核心原理</h2><ol>
<li><p>通过<code>new VueRouter</code>中的<code>mode</code>参数来选择使用那种路由模式</p>
</li>
<li><p>在<code>router</code>中使用<code>current</code>保存当前url</p>
</li>
<li><p>作为一个插件，大部分功能都在<code>install</code>函数中完成</p>
</li>
<li><p>在<code>install</code>中使用<code>Vue.mixin</code>注入的<code>beforeCreate</code>来给组件添加全局唯一的<code>router</code>实例（挂载在根组件上，其余组件通过<code>$parent._routerRoot._router</code>挂载）</p>
</li>
<li><p>使用<code>popstate</code>或<code>hashchange</code>两个事件来监听url变化（针对于手动输入url）并设置<code>current</code></p>
</li>
<li><p>使用<code>Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)</code>来使<code>router</code>变为响应式</p>
<p>current变化    👉    重新渲染<code>router-view</code>中的组件 </p>
</li>
<li><p>解析路由配置从而可以更加便利地找到url所对应的页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>&lt;&#123; <span class="attr">name</span>: component &#125;&gt;</span><br></pre></td></tr></table></figure>

<p>👇</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;&#123; <span class="attr">name</span>: component &#125;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>&lt;router-link&gt;&lt;/router-link&gt;</code>和<code>&lt;router-view / &gt;</code>两个组件</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>vue-router</code>以插件方式侵入<code>Vue</code>，从而支持一个额外的<code>router</code>属性，以提供监听并改变组件路由数据的能力，这样每次路由发生变化后，可以同步到数据，从而响应式地触发组件的更新</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-router.png" alt="vue-router"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrrs878.github.io/2020/03/06/Vue.js研读-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.RS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/imgs/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.RS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            
            <a href="/2020/03/06/Vue.js研读-4/" class="post-title-link" itemprop="url">Vue.js研读-4</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-03-06 23:29:53" itemprop="dateCreated datePublished" datetime="2020-03-06T23:29:53+08:00">2020-03-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-11 14:26:35" itemprop="dateModified" datetime="2020-03-11T14:26:35+08:00">2020-03-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue-js/" itemprop="url" rel="index">
                    <span itemprop="name">Vue.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="生命周期概览"><a href="#生命周期概览" class="headerlink" title="生命周期概览"></a>生命周期概览</h2><p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/lifecycle.png" alt="生命周期"></p>
<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul>
<li><p>beforeCreate</p>
<p><code>new Vue()</code>之后触发的第一个钩子，在当前阶段<code>data</code>、methods、<code>computed</code>以及watch上的数据和方法均不能被访问</p>
</li>
<li><p>created</p>
<p>在实例创建完成之后触发，当前阶段已完成了数据观测，也就是可以使用数据，更改数据，在这个更改数据不会触发<code>updated</code>函数。可以做一些<strong>初始数据的获取</strong>，在当前阶段无法获取DOM（可使用vm.$nextTick）</p>
</li>
<li><p>beforeMounte</p>
<p>发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟DOM已创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发<code>updated</code></p>
</li>
<li><p>mounted</p>
<p>在挂载之后被触发。在当前阶段，真实的DOM被挂载完毕，数据完成双向绑定，可以访问到DOM阶段，使用$ref属性对DOM进行操作</p>
</li>
<li><p>beforeUpdate</p>
<p>在界面发生更新之前被触发。也就是响应式数据发生改变之前、虚拟DOM重新渲染之前被触发，可以在此阶段进行更改数据，不会造成重渲染</p>
</li>
<li><p>updated</p>
<p>在发生更新之后被触发。当前阶段DOM已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</p>
</li>
<li><p>beforeDestory</p>
<p>在实例被销毁之前触发。在当前阶段实例完全可以被使用，可以在此阶段做些善后工作，如清除定时器</p>
</li>
<li><p>destoryed</p>
<p>在实例被销毁之后触发。这个时候只剩下DOM，组件已被拆解，数据绑定被卸载、监听被移除、子实例也统统被销毁</p>
</li>
</ul>
<h2 id="组件的生命周期函数调用顺序"><a href="#组件的生命周期函数调用顺序" class="headerlink" title="组件的生命周期函数调用顺序"></a>组件的生命周期函数调用顺序</h2><ul>
<li><p>加载渲染顺序</p>
<p>父beforeCreate👉父created👉父beforeMmount👉子beforeCreate👉子created👉子beforeMount👉子mounted👉父mounted</p>
</li>
<li><p>更新顺序</p>
<p>父beforeUpdate👉子beforeUpdate👉子updated👉父updated</p>
</li>
<li><p>销毁顺序</p>
<p>父beforeDestory👉子beforeDestory👉子destoryed👉父destoryed</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/imgs/avatar.png"
      alt="Mr.RS">
  <p class="site-author-name" itemprop="name">Mr.RS</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.RS</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>
